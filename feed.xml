<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.9.0">Jekyll</generator><link href="https://sanseongko.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="https://sanseongko.github.io/" rel="alternate" type="text/html" /><updated>2021-06-24T17:39:57+09:00</updated><id>https://sanseongko.github.io/feed.xml</id><title type="html">SanseongKo’s Blog</title><subtitle>온리 공부를 위한 블로그</subtitle><entry><title type="html">카카오 2021 블라인드 코딩테스트 1번</title><link href="https://sanseongko.github.io/codingtest-2021_kakao01" rel="alternate" type="text/html" title="카카오 2021 블라인드 코딩테스트 1번" /><published>2021-06-15T00:00:00+09:00</published><updated>2021-06-15T00:00:00+09:00</updated><id>https://sanseongko.github.io/codingtest-2021_kakao01</id><content type="html" xml:base="https://sanseongko.github.io/codingtest-2021_kakao01">&lt;h3&gt;문제&lt;/h3&gt;
&lt;p&gt;카카오에 입사한 신입 개발자 네오는 “카카오계정개발팀”에 배치되어, 카카오 서비스에 가입하는 유저들의 아이디를 생성하는 업무를 담당하게 되었습니다.
“네오”에게 주어진 첫 업무는 새로 가입하는 유저들이 카카오 아이디 규칙에 맞지 않는 아이디를 입력했을 때, 입력된 아이디와 유사하면서 규칙에 맞는 
아이디를 추천해 주는 프로그램을 개발하는 것입니다.
&lt;br /&gt;
&lt;a href=&quot;https://tech.kakao.com/2021/01/25/2021-kakao-recruitment-round-1/&quot;&gt;문제 자세히 보기&lt;/a&gt;&lt;/p&gt;

&lt;h3&gt;풀이&lt;/h3&gt;
&lt;p&gt;7가지의 조건들을 순서대로 적용하여 문제를 풀었다.
&lt;br /&gt;
&lt;script src=&quot;https://gist.github.com/sanseongKo/dab3325f2e1466eb26eca73783ed6b46.js&quot;&gt;&lt;/script&gt;
&lt;br /&gt;
순서대로 적용시키면 되기 때문에, 어렵진 않았지만 코드가 좀 더러운 느낌…?(멀었다… 멀었어…)&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/sanseongKo/codingtest&quot;&gt;깃허브에서 보기&lt;/a&gt;&lt;/p&gt;

&lt;h3&gt;새로 알게된 메소드&lt;/h3&gt;
&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nb&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;id&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;new_id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;toLowerCase&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;오 소문자로 바로 바꿔주더이다, 처음 생각한건 아스키 코드였는데 있다면 안 쓸 이유가 없지. 물론, new_id.toUpperCase();를 하면 대문자로 변환 해
준다.(대문자, 소문자만 확인하여 변환하고 숫자나 기타 특수문자는 건들지 않아서 문제에 유용했다.)
&lt;br /&gt;&lt;/p&gt;
&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nx&quot;&gt;char&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;answer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;toCharArray&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;솔직히 몰랐다… 반복으로 char 배열에 넣어줘야 하는 줄 알았다…&lt;/p&gt;

&lt;p&gt;다 풀고나서, 다른 분의 풀이를 보았다… 잘한다… 
&lt;br /&gt;
정규 표현식&lt;/p&gt;</content><author><name>Ko</name></author><category term="codingtest" /><summary type="html">문제 카카오에 입사한 신입 개발자 네오는 “카카오계정개발팀”에 배치되어, 카카오 서비스에 가입하는 유저들의 아이디를 생성하는 업무를 담당하게 되었습니다. “네오”에게 주어진 첫 업무는 새로 가입하는 유저들이 카카오 아이디 규칙에 맞지 않는 아이디를 입력했을 때, 입력된 아이디와 유사하면서 규칙에 맞는 아이디를 추천해 주는 프로그램을 개발하는 것입니다. 문제 자세히 보기</summary></entry><entry><title type="html">inflearn강의 Sort and Searching복습</title><link href="https://sanseongko.github.io/codingtest-sortcodingclass" rel="alternate" type="text/html" title="inflearn강의 Sort and Searching복습" /><published>2021-06-15T00:00:00+09:00</published><updated>2021-06-15T00:00:00+09:00</updated><id>https://sanseongko.github.io/codingtest-sortcodingclass</id><content type="html" xml:base="https://sanseongko.github.io/codingtest-sortcodingclass">&lt;p&gt;정렬 알고리즘 강의 들은 것에 관하여 정리를 해보려 한다.(요기요 코딩테스트도 오늘 보았다)
첫번째 문제에서는 조건에 맞는 배열의 데이터를 빼내어 다른 배열에 담고, 인덱스를 기억하여 정렬을 하는 것이 핵심이었다.
인덱스를 증가 시켜놓은 상태로, 또는 인덱스를 최대에서 줄이면서, 인덱스를 기억시켜놓고 인덱스에 맞게 정렬을 하는 방식이다.
언제나 문제의 조건을 정리하여 그대로 코딩화하는 것이 중요한 것 같다.&lt;/p&gt;

&lt;p&gt;두번째 문제는 힙을 이용하여 정렬을 하는 방법이고, 큰 수부터 정렬하여 그 중 몇 번째 숫자를 리턴하는 것이다.
Priority Queue&lt;/p&gt;</content><author><name>Ko</name></author><category term="codingtest" /><summary type="html">정렬 알고리즘 강의 들은 것에 관하여 정리를 해보려 한다.(요기요 코딩테스트도 오늘 보았다) 첫번째 문제에서는 조건에 맞는 배열의 데이터를 빼내어 다른 배열에 담고, 인덱스를 기억하여 정렬을 하는 것이 핵심이었다. 인덱스를 증가 시켜놓은 상태로, 또는 인덱스를 최대에서 줄이면서, 인덱스를 기억시켜놓고 인덱스에 맞게 정렬을 하는 방식이다. 언제나 문제의 조건을 정리하여 그대로 코딩화하는 것이 중요한 것 같다.</summary></entry><entry><title type="html">inflearn강의 복습</title><link href="https://sanseongko.github.io/codingtest-codingclass" rel="alternate" type="text/html" title="inflearn강의 복습" /><published>2021-06-15T00:00:00+09:00</published><updated>2021-06-15T00:00:00+09:00</updated><id>https://sanseongko.github.io/codingtest-codingclass</id><content type="html" xml:base="https://sanseongko.github.io/codingtest-codingclass">&lt;p&gt;뭔가 계속 불안해서 결국 인프런의 강의를 질렀다. 강의에서 나오는 내용들 위주로 공부를 진행하려고 한다.&lt;/p&gt;

&lt;h3&gt;String&lt;/h3&gt;
&lt;p&gt;&lt;b&gt;사전지식&lt;/b&gt;
&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;charAt(i) =&amp;gt; 문자열 위치(String “abcd”가 있으면 a는 charAt(1))&lt;/li&gt;
  &lt;li&gt;toCharArray =&amp;gt; char[]배열로 바꿔줌(위의 abcd를 배열로 바꿔줌)&lt;/li&gt;
  &lt;li&gt;IndexOf(), substring(begin, end) (특정 문자를 찾고 싶을 때, end인덱스는 마지막에서 끊는다)&lt;/li&gt;
  &lt;li&gt;startsWith(), endWith(), split() (ex. str.startWith(“a”)); =&amp;gt; true, split() =&amp;gt; 문자열을 특정 조건으로 스트링 배열로 바꿔줄 수 있음)&lt;/li&gt;
  &lt;li&gt;toLowerCase() =&amp;gt; 소문자로 바꿔줌&lt;/li&gt;
  &lt;li&gt;replace() =&amp;gt; 특정한 문자가 나오면 그거를 뭐로 바꿔줘라&lt;/li&gt;
  &lt;li&gt;Character,isDigit(c), Character.isLetter (전자 =&amp;gt; 0,1이런 숫자냐, 후자 =&amp;gt; 문자이냐) –&amp;gt; true&lt;/li&gt;
  &lt;li&gt;StringBuilder sb = new StringBuilder(); ex) sb.append(“aa”)&lt;/li&gt;
&lt;/ol&gt;

&lt;h3&gt;String 문제 1&lt;h3&gt;
1. Basic한 방법으로, 이메일이 담기는 배열을 파라미터로 받을 경우, for문을 돌려 각 이메일마다 charAt으로 나눠주고 조건을 확인시키는 방법이다. 
여기서 주의할 점은 substring(숫자) 이 숫자 부분이 배열의 번호부터 출력이 된다.
   
2. split을 가지고 하는 방법으로, 각 조건마다 split으로 String 배열로 만들어주고 그 배열을 replace(&quot;.&quot;, &quot;&quot;)로 바꿔주면 된다. 굉장히 간단했다.

&lt;br /&gt;&lt;br /&gt;

&lt;b&gt;1번 문제의 시간복잡도/공간복잡도 계산&lt;/b&gt;
&lt;br /&gt;&lt;br /&gt;
1. 시간 복잡도 : 대상 =&amp;gt; 문제에서 입력받은 파라미터 (속도)
2. 공간 복잡도 : 대상 =&amp;gt; 실제 사용되는 저장 공간을 계산
&lt;br /&gt;&lt;br /&gt;
&lt;b&gt;참고&lt;/b&gt;
   &lt;br /&gt;&lt;br /&gt;
1. O(1): 스택, 큐, Map
2. O(N): for문 =&amp;gt; 데이터를 한번씩 호출하기 때문
3. O(logN): sort, priorityQueue, binary Search Tree, Tree
4. O(KlogN): k번만큼 소팅하는 경우
5. O(N^2): 이중 for문
6. O(m*n): 이중 for문이지만, n이 다른 경우 bfs, dfs류 

&lt;br /&gt;&lt;br /&gt;
&lt;h3&gt;2. 보석 찾기 문제&lt;/h3&gt;

&lt;b&gt;Set&lt;/b&gt;은 대소문자를 구별한다. Set.contain(something) something이 Set에 들어있는지 확인 시켜줄 수 있다.(count를 할 때 유용할 듯)

&lt;h3&gt;3. 문자 파싱 문제&lt;/h3&gt;
&lt;b&gt;StringBuilder&lt;/b&gt;의 insert 메소드를 사용, (insert(8, &quot;!&quot;))이렇게 되어 있으면, 배열처럼 0번부터 시작해서 8번째에 해당 문자를 삽입한다.
삽입하고 딱 그자리에 들어가고 나머지는 밀리는 느낌이기 때문에, 잘 계산해서 사용하여야 겠다.

&lt;br /&gt;&lt;br /&gt;
제일 중요한건, 사실 생각인 것 같다. 코딩테스트 문제를 풀어봐도 항상 나는 구현쪽에서 막힌다.(그만큼 아는게 적다는 뜻이겠지)&lt;br /&gt;
어지간하면 문제 이해는 어렵지 않다. 어떤 것을 사용할지도 머리에 떠오르지만 중간 중간 문제되는 부분들에 막히면서 코드가 복잡해진다.&lt;br /&gt;
아는 선에서 생각하고 바로 떠오르긴 하지만 그것이 제대로 된 접근이 아니기 때문에 문제 해결을 위하여 코드가 추가되다보니 복잡해지고 시간을 잡아 먹는 것 같다.
초반 스트링의 관한 문제들이기 때문에, 그렇게 어렵게 다가오지 않았다. 원래 목표는 dfs,bfs의 이해이기 때문에(찾아보니, 속도가 굉장히 느린데 왜 쓰는건지 궁금;;) 달려보자.




&lt;/h3&gt;&lt;/h3&gt;</content><author><name>Ko</name></author><category term="codingtest" /><summary type="html">뭔가 계속 불안해서 결국 인프런의 강의를 질렀다. 강의에서 나오는 내용들 위주로 공부를 진행하려고 한다.</summary></entry><entry><title type="html">기술 면접 예상 질문</title><link href="https://sanseongko.github.io/interview" rel="alternate" type="text/html" title="기술 면접 예상 질문" /><published>2021-06-13T00:00:00+09:00</published><updated>2021-06-13T00:00:00+09:00</updated><id>https://sanseongko.github.io/interview</id><content type="html" xml:base="https://sanseongko.github.io/interview">&lt;p&gt;기술 면접에 관하여, 내가 지원하려고 하는 자바, 스프링, 관련 지식 또는 CS관련 지식들을 적고 대답을 적어보는 포스팅을 하려고 한다.
면접에 가서 모른다는 답변을 너무 많이했다… 아는 건데 막상 설명을 하려니 못하겠어서 찾아보고 정리하고 정확하게 말을 할 수 있을 정도가 되었으면 한다.&lt;/p&gt;

&lt;h3&gt;자바&lt;/h3&gt;
&lt;p&gt;면접 질문 중에 쓰레드에 관한 질문이 나왔고, 쓰레드를 알고 있었지 자바에서 구현 가능한지는 몰랐다. 하지만 찾아보니 써봤던 거다.&lt;/p&gt;

&lt;h3&gt;자바에서 쓰레드&lt;/h3&gt;
&lt;p&gt;내가 찾아본 자바에서 쓰레드는 보통 코드가 한번에 하나씩 실행이 된다고 한다. 그렇지만, 여기에 쓰레드를 상속받아 사용한다면, start() 메소드를 사용할 
수 있고, start()가 실행될 때 run()를 수행하게 되어 있다.&lt;/p&gt;

&lt;h3&gt;사용 이유&lt;/h3&gt;
&lt;p&gt;보통은 동시에 많은 양의 요청이 들어오는 서비스에서, 그 요청들을 하나씩 처리한다면, 많은 시간이 소요가 될 것이다. 그렇게 많은 시간이 소요되는 부분을
동시에 처리하여 시간을 줄이기 위하여 사용이 된다. 하지만 쓰레드가 많아질 경우 컴퓨터의 부하가 심해지고, [교착상태]가 날 수 있기 때문에 주의하여 
사용을 해야한다.&lt;/p&gt;

&lt;h3&gt;사용 예&lt;/h3&gt;
&lt;script src=&quot;https://gist.github.com/sanseongKo/bda05eab70c50f964b821697d6eafcf4.js&quot;&gt;&lt;/script&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;./assets/built/images/interview/thread/threadcode.PNG&quot; alt=&quot;ex_screenshot&quot; /&gt;
위의 결과 처럼 원래대로라면, 생성자를 생성하고 run()이 순차적으로 실행되어야 하는데, 유저가 랜덤하게 메세지를 보내고 있는 것을 확인할 수 있다.&lt;/p&gt;</content><author><name>Ko</name></author><category term="interview" /><summary type="html">기술 면접에 관하여, 내가 지원하려고 하는 자바, 스프링, 관련 지식 또는 CS관련 지식들을 적고 대답을 적어보는 포스팅을 하려고 한다. 면접에 가서 모른다는 답변을 너무 많이했다… 아는 건데 막상 설명을 하려니 못하겠어서 찾아보고 정리하고 정확하게 말을 할 수 있을 정도가 되었으면 한다.</summary></entry><entry><title type="html">Spring Security 연습</title><link href="https://sanseongko.github.io/springsecurity" rel="alternate" type="text/html" title="Spring Security 연습" /><published>2021-06-13T00:00:00+09:00</published><updated>2021-06-13T00:00:00+09:00</updated><id>https://sanseongko.github.io/springsecurity</id><content type="html" xml:base="https://sanseongko.github.io/springsecurity">&lt;p&gt;기술 면접중 스프링 시큐리티에 관하여 질문을 받았고, 대답을 못했다. 돌아가는 모습은 내가 아는 모습은 비슷하지만, 지원을 해주는 것에서 많이 차이가
나는 것 같다. 편한기능이 많고, 알아두면 좋을 것 같다. 물론 어떻게 돌아가는지도 넣을 것이고, 자료는 유튜브 &lt;a href=&quot;https://www.youtube.com/watch?v=riwrVN1JVbU&quot;&gt;데어 프로그래밍&lt;/a&gt;님의
유튜브에서 가져왔고 설명이 잘되어 있는 것 같으니, 궁금할 땐 클릭해서 들어가 보자.(유튜브로 강의를 정말 잘해 놓으셨다.)&lt;/p&gt;

&lt;h3&gt;Spring Security 연습 1(2021-06-17)&lt;/h3&gt;

&lt;p&gt;&lt;br /&gt;
처음 시작에서 Spring Security 의존주입을 하고 나서, yml파일을 생성하고 내용을 정리해준다. 브라우저에 접속하여 url을 적으면, 자동으로 스프링
시큐리티가 login페이지로 넘겨준다. 아이디는 기본 user이며, 비밀번호는 처음 서버를 실행하고 나서 콘솔에 사진처럼 나타나게된다. spring security 
의존주입시 처음 들어가는 모든 요청 페이지는 막혀서 로그인을 해줘야하고 로그인이 되어야 접근이 가능하다는 점 유의하자. 또한 로그아웃도 지원하기 때문에, 
다시 서버를 실행하였다면, 로그아웃 한번 해주고 실행하자.(비밀번호도 재실행 될 때마다 변경됨)
&lt;img src=&quot;./assets/built/images/spring/securitypassword.PNG&quot; alt=&quot;ex_screenshot&quot; /&gt;
&lt;b&gt;MustacheViewResolver&lt;/b&gt;
해당 유튜브 강의에서는 html을 이용하여 초반에 뷰를 작성하였다. 하지만 처음 의존 주입을 Mustache로 하였기 때문에, 해당 configuration 클래스를
생성하고, MustacheViewResolver자료형으로 참조변수를 만들어 사용할 수 있다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-angular2html&quot;&gt;MustacheViewResolver resolver = new MustacheViewResolver();
		resolver.setCharset(&quot;UTF-8&quot;);
		resolver.setContentType(&quot;text/html; charset=UTF-8&quot;);
		resolver.setPrefix(&quot;classpath:/templates/&quot;);
		resolver.setSuffix(&quot;.html&quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이런식으로 만들어졌을 경우 .mustache로 설정되어 있던 suffix가 html로 경로 설정이 될 수 있도록 해준다.&lt;/p&gt;

&lt;h3&gt;Spring Security 연습 2(2021-06-18)&lt;/h3&gt;
&lt;p&gt;&lt;b&gt;@EnableWebSecurity&lt;/b&gt;
웹 보안을 활성화하고, WebSecurityConfigurer을 상속받아 클래스를 설정할 때 자주 쓰인다. @Configuration 클래스에 @EnableWebSecurity을 추가하여
스프링 시큐리티를 설정할 클래스라고 정의한다.
&lt;br /&gt;
&lt;br /&gt;
&lt;b&gt;WebSecurityConfigurer&lt;/b&gt;는 WebSecurityConfigurer 인스턴스를 편리하게 만들기 위하여 사용한다. 상속을 받게 되면, configure 메소드를 오버
라이딩 할 수 있고, 파라미터는 HttpSecurity 객체를 받게 된다.
&lt;br /&gt;
&lt;br /&gt;
&lt;b&gt;authorizeRequests()&lt;/b&gt;메서드는 시큐리티 처리에 HttpServletRequest를 이용한다는 것을 의미하고,
&lt;br /&gt;
&lt;br /&gt;
&lt;b&gt;antMatchers()&lt;/b&gt;는 특정 경로를 지정해줄 수 있는 메소드이다.
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;h4&gt;특정 경로 지정 후 사용 할 수 있는 인증 메서드&lt;/h4&gt;
&lt;p&gt;anonymous(): 인증되지 않은 사용자가 접근할 수 있습니다.
authenticated(): 인증된 사용자만 접근할 수 있습니다.
fullyAuthenticated(): 완전히 인증된 사용자만 접근할 수 있습니다(?)
hasRole() or hasAnyRole(): 특정 권한을 가지는 사용자만 접근할 수 있습니다.
hasAuthority() or hasAnyAuthority():특정 권한을 가지는 사용자만 접근할 수 있습니다.
hasIpAddress(): 특정 아이피 주소를 가지는 사용자만 접근할 수 있습니다.
access(): SpEL 표현식에 의한 결과에 따라 접근할 수 있습니다.
not(): 접근 제한 기능을 해제합니다.
permitAll() or denyAll(): 접근을 전부 허용하거나 제한합니다.
rememberMe(): 리멤버 기능을 통해 로그인한 사용자만 접근할 수 있습니다.
&lt;br /&gt;
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;출처: &lt;a href=&quot;https://postitforhooney.tistory.com/entry/SpringSecurity-초보자가-이해하는-Spring-Security-퍼옴&quot;&gt;PostIT&lt;/a&gt;
&lt;br /&gt;
&lt;br /&gt;
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;또한 이후에,&lt;/p&gt;
&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;formLogin&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;loginPage&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;/loginForm&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;loginProcessingUrl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;/login&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;defaultSuccessUrl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;이렇게 작성을 하게된다면, loginPage는 로그인 페이지가 어디인지, loginProcessingUrl은 login주소가 호출될 떄 시큐리티가 낚아채서 대신 로그인을 진행해주는 메소드이며,
.defaultSuccessUrl은 로그인 이후에 보여질 기본 페이지이며, 특정페이지로 접속하려 할 때 인증이 필요하여 로그인 페이지로 넘어갈 경우 그 로그인페이지에서 전에 config에서 설정해 놓은 기본 경로로
가지 않고 특정페이지가 보여지게 된다.
&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;b&gt;OAuth(2021-06-23추가)&lt;/b&gt;&lt;br /&gt;&lt;br /&gt;
OAuth2는 인증을 위한 표준 프로토콜이다.(정의) 
해당 인증으로 타 사이트의 API를 이용할 수 있게 되는 것이다.
스프링 시큐리티 라이브러리중 OAuth라는 라이브러리가 있었다. 예전 프로젝트를 할 때 네이버나 카카오 로그인 API를 사용할 때 개인 키를 적어두고 이를 사용해서 
토큰과 정보를 받아왔었다. 하지만, OAuth Client 라이브러리를 사용하니 그럴 필요없이 정해진 경로로 매핑을 해놓고, 키와 비밀번호를 property.yml에 저장해
놓으니, 굳이 토큰을 받아올 uri을 적고 가져오는 코드를 작성할 필요없이 로그인에 필요한 정보를 가져올 수 있었다.
예를 들어 구글 로그인 API를 사용할 경우 http://localhost:8080/login/oauth2/code/google 적었다고 하면, login/oauth2/code/은 고정이고 이후
google이나 facebook등은 해당 사이트에 맞게 적어주면 되었다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://developers.payco.com/guide/development/start&quot;&gt;페이코 개발자 센터&lt;/a&gt; 해당 링크에서 OAuth의 인증과정과 프로세스를 확인 할 수 있다.
&lt;br /&gt;&lt;br /&gt;
OAuth서비스 코드를 작성할 때 DefaultOAuth2UserService를 상속받아 사용하면 되며, loadUser 메소드를 오버라이드하여 안에 내용을 채워주면 된다.
&lt;br /&gt;&lt;br /&gt;
해당 유튜브 영상을 보며, 모르겠는 메소드를 찾아보았다.
&lt;br /&gt;&lt;br /&gt;
&lt;b&gt;userInfoEndpoint&lt;/b&gt;
OAuth2 로그인 성공 이후 사용자 정보를 가져올 때의 설정을 담당
&lt;br /&gt;&lt;br /&gt;
&lt;b&gt;userService&lt;/b&gt;
소셜 로그인 완료 후 후조치를 진행할 UserService 인터페이스의 구현체를 등록해줘야함
&lt;br /&gt;&lt;br /&gt;
후속 조치로는 데이터를 받아오면 바로 가입시켜주든 회원 가입 페이지로 이동을 시키든 할 수 있고, 아무래도 예전 프로젝트에서 사용하는 코드들 보다 많이
유용하고 편리하였다. 하지만 그래도 부트를 사용하기전 스프링에서 로그인 API사용하기 위한 코드를 직접 만들었던 적이 있어서 그런지 돌아가는 구조를 이해하는데
쉬웠다.&lt;/p&gt;</content><author><name>Ko</name></author><category term="spring" /><summary type="html">기술 면접중 스프링 시큐리티에 관하여 질문을 받았고, 대답을 못했다. 돌아가는 모습은 내가 아는 모습은 비슷하지만, 지원을 해주는 것에서 많이 차이가 나는 것 같다. 편한기능이 많고, 알아두면 좋을 것 같다. 물론 어떻게 돌아가는지도 넣을 것이고, 자료는 유튜브 데어 프로그래밍님의 유튜브에서 가져왔고 설명이 잘되어 있는 것 같으니, 궁금할 땐 클릭해서 들어가 보자.(유튜브로 강의를 정말 잘해 놓으셨다.)</summary></entry><entry><title type="html">Algorithm Greedy(탐욕법)에 관하여</title><link href="https://sanseongko.github.io/algorithm-greedy" rel="alternate" type="text/html" title="Algorithm Greedy(탐욕법)에 관하여" /><published>2021-06-11T00:00:00+09:00</published><updated>2021-06-11T00:00:00+09:00</updated><id>https://sanseongko.github.io/algorithm-greedy</id><content type="html" xml:base="https://sanseongko.github.io/algorithm-greedy">&lt;p&gt;오늘은 알고리즘 중 하나인 Greedy에 관하여 알아보도록 하겠다.&lt;/p&gt;

&lt;h3&gt;Greedy&lt;/h3&gt;
&lt;p&gt;Greedy 탐욕법 알고리즘은 결과까지는 생각하지 않고 매 순간 최선이라고 생각되는 것을 선택해 결과까지 도달하는 알고리즘이다. 설명과 같이 매 순간 최
선인 선택을 하고 그 이후의 선택은 이후에 판단하기 때문에 언제나 옳은 알고리즘은 아닐 수 있다. 그렇기 때문에, 현상황에서 선택하는 최선의 수를 선택
한다면 결과도 최선이 되는 경우에 사용하여야 알맞다.
보통은 활동 선택 문제, 거스름돈 문제, 최소 신장 트리, 다익스트라 알고리즘에 활용이 가능하며, 살펴보다면 결국 매순간 최적의 선택을하고 그 선택들이
다음 선택과 전혀 무관하더라도 최적의 경우를 찾을 수 있는 문제에 사용이 가능한 것을 알 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;b&gt;탐욕범을 위한 문제&lt;/b&gt;
탐욕법의 정의이고, 나머지는 문제를 풀어보며 어떻게 접근하여야 할지 생각해 봐야하겠다. 추가적인 문제를 다룰 경우 추가 포스팅 예정임.&lt;/p&gt;</content><author><name>Ko</name></author><category term="algorithm" /><summary type="html">오늘은 알고리즘 중 하나인 Greedy에 관하여 알아보도록 하겠다.</summary></entry><entry><title type="html">Java REST API 실습</title><link href="https://sanseongko.github.io/java-restapipractice" rel="alternate" type="text/html" title="Java REST API 실습" /><published>2021-06-10T00:00:00+09:00</published><updated>2021-06-10T00:00:00+09:00</updated><id>https://sanseongko.github.io/java-restapipractice</id><content type="html" xml:base="https://sanseongko.github.io/java-restapipractice">&lt;p&gt;REST API를 너무 해보고 싶어 하나 하나 전부 뜯어 보려한다. 강의를 사서 볼까도 했지만, 오기가 생겨서 다 찾아보고 적어보려고 한다. 스프링 부트의 
어노테이션에 관한 것도 같이 올릴 것이다. 또한 하루만에 완성하는 포스팅이 아니기 때문에, 수정날짜를 밑에 적도록 하겠다.&lt;/p&gt;

&lt;b3&gt;@Data&lt;/b3&gt;
&lt;p&gt;&lt;br /&gt;
Data어노테션의 경우 getter setter tostring hashcode equals전부 만들어주는 어노테이션으로 lombok 라이브러리에서 사용이 가능하며, 
@Getter, @Setter, @ToString, @EqualsAndHashCode 로 나누어 사용도 가능하며, get, set, toString, eqauls, hashcode 원하는 메서드를
사용할 수도 있다.&lt;/p&gt;

&lt;p&gt;&lt;b&gt;@NoArgsConstructor&lt;/b&gt;
&lt;br /&gt;
파라미터가 없는 생성자를 만들어주는 어노테이션이다.
&lt;b&gt;@AllArgsConstructor&lt;/b&gt;
&lt;br /&gt;
모든 파라미터로, 모든 필드에 대한 생성자를 만들어주는 어노테이션이다.&lt;/p&gt;

&lt;p&gt;&lt;b&gt;@Entity&lt;/b&gt;
&lt;br /&gt;
@Entity는 DB의 테이블과 일대일로 매칭되는 객체의 단위이며, 기본 생성자가 필요하고, 필드에 final interface class를 사용할 수 없다. 또한 name
을 주면 엔티티의 이름을 지정하고 @Entity가 붙은 클래스는 JPA에서 관리하게 된다.&lt;/p&gt;

&lt;p&gt;&lt;b&gt;@Table(name = “”)&lt;/b&gt;
&lt;br /&gt;
@Table없이 테이블을 생성하게 될 경우 Entity 클래스의 카멜표기법을 유지한 상태로 테이블이 생성되기 때문에 작성해주는 것이 관례이다.&lt;/p&gt;

&lt;p&gt;&lt;b&gt;@Id&lt;/b&gt;
&lt;br /&gt;
@Id어노테이션을 인스턴스에 붙이게 될 경우, PK와 같은 의미가 된다. 또한 @GerneratedValue를 사용할 경우 해당 변수의 수가 자동으로 증가하게 된다.
(sequence와 같은 의미.)&lt;/p&gt;

&lt;p&gt;&lt;b&gt;Spring Data JPA 쿼리 메소드안에 지원되는 키워드&lt;/b&gt;
findBy 이런 형태가 쿼리 메소드 구문 이러면 자동으로 sql구문을 만들어 준다. 지원되는 키워드는 &lt;a href=&quot;https://happygrammer.tistory.com/158&quot;&gt;happygrammer&lt;/a&gt;님의
블로그에 정리가 되어있어 링크해두겠다.&lt;/p&gt;

&lt;p&gt;&lt;b&gt;OrElseThrow 메소드&lt;/b&gt;
&lt;br /&gt;
해당 메소드의 경우 java.util.Optiona을 임포트하여 사용이 가능하고, 실습 중에서는
Optional&lt;Emp&gt; org.springframework.data.repository.CrudRepository.findById(Integer id)메서드를 사용할 때 사용이 가능했다. 
따로 에러처리를 해주지 않고, 에러가 날 경우 에러처리를 위한 클래스로 보내지는 메소드이다.&lt;/Emp&gt;&lt;/p&gt;

&lt;p&gt;추가적인 부분은 현재 The type org.springframework.util.MultiValueMap cannot be resolved. It is indirectly referenced from required .class files
에러가 나서 이후에 올려보겠다.
&lt;b&gt;2021-06-11&lt;/b&gt;
&lt;br /&gt;
어제의 에러는 spring-core자르 파일이 문제가 있어 발생하여 외부에서 파일을 가져와 라이브러리를 추가하니 해결이 되었다.를 하자마자 새로운 오류 
Consider defining a bean named ‘entityManagerFactory’ in your configuration. 발생, 해결하고 돌아와야지…
이 부분은 톰캣 버전을 9로 맞춰주고 .m2폴더에 hibernate폴더를 지우고 다시 빌드하여 문제를 해결하였다.&lt;/p&gt;

&lt;p&gt;&lt;b&gt;2021-06-12&lt;/b&gt;
&lt;br /&gt;
정의해 두었던 메소드를 사용하여 데이터를 삽입 실행시에 테이블을 생성하게 하여 실행하였을 때 데이터가 삽입되고, 테이블이 만들어지는 것을 확인,HeildiSql에
데이터가 담기고 브라우저에 해당 데이터들이 제이슨형태로 보여지는 것까지 확인하였다. 예전 legacy로 한 프로젝트 안에서 모든걸 처리할 때, 컨트롤러의 리턴
값을 JSP로 보내주었었는데, 이것을 레스트 API에선 리턴 값을 상태코드와 같이 보내주는 것을 보고, 머리속으로 그려지던게 조금 더 가까이 느껴졌다. 이제
초석은 다졌으니 레스트 API의 제약 조건을 조금 더 알아보고 추가해보고 기존에 만들었던 프로젝트를 API화 시켜 REST방식으로 통신하는 것까지 진행해 보겠다.
이 연습은 여기서 끝~&lt;/p&gt;

&lt;p&gt;&lt;b&gt;2021-06-13&lt;/b&gt;
&lt;b&gt;Hateoas&lt;/b&gt;
&lt;br /&gt;
Rest Api의 제약 조건중 Hateoas의 제약 조건이 제일 맞추기 어려운 것을 보았다. Hypermedia As The Engine Of Application State의 약자이다.
Hateoas는 링크를 통하여 어플리케이션의 상태가 전이되어야 하고, 링크에 자신의 정보가 담겨야 한다는 것이다. 이 말의 뜻은, 링크의 URI자원이 명시되어 있어야 
하며, 클라이언트가 서버와 동적으로 상호작용이 가능하다는 말이다. 클라이언트가 서버에 POST요청을 보냈다고 가정했을 때, 이에 의존되는 GET, PUT, DELETE등의 
URI를 Reponse에 포함하여 반환 시킨다. 
응답 예:&lt;/p&gt;
&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;게시글 1&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;content&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;HAL JSON을 이용한 예시 JSON&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;http://localhost:8080/api/article/1000&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 현재 api 주소&lt;/span&gt;
    &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;profile&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;http://localhost:8080/docs#query-article&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 해당 api의 문서&lt;/span&gt;
    &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;http://localhost:8080/api/article/1001&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 다음 article을 조회하는 URI&lt;/span&gt;
    &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;comment&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;http://localhost:8080/api/article/comment&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// article의 댓글 달기&lt;/span&gt;
    &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;save&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;http://localhost:8080/api/feed/article/1000&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// article을 내 피드로 저장&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;이 부분은 지켜지지 않고 있는 API들이 많으며, 스프링의 라이브러리를 사용하여 조금 더 쉽게 접근할 수 있기 때문에 다음엔, 라이브러리에서 제공하는 것을,
사용하여 적용시켜 보겠다.&lt;/p&gt;

&lt;p&gt;출처: &lt;a href=&quot;https://www.youtube.com/watch?v=Xb0OEOiZ3Rg&quot;&gt;오라클 자바 커뮤니티&lt;/a&gt;
&lt;a href=&quot;https://wonit.tistory.com/454&quot;&gt;Wonit&lt;/a&gt;
깃허브: &lt;a href=&quot;https://github.com/sanseongKo/restapipractice&quot;&gt;sanseongKo&lt;/a&gt;&lt;/p&gt;</content><author><name>Ko</name></author><category term="java" /><summary type="html">REST API를 너무 해보고 싶어 하나 하나 전부 뜯어 보려한다. 강의를 사서 볼까도 했지만, 오기가 생겨서 다 찾아보고 적어보려고 한다. 스프링 부트의 어노테이션에 관한 것도 같이 올릴 것이다. 또한 하루만에 완성하는 포스팅이 아니기 때문에, 수정날짜를 밑에 적도록 하겠다.</summary></entry><entry><title type="html">Algorithm 완전 탐색에 관하여</title><link href="https://sanseongko.github.io/algorithm-Exhaustive-Search" rel="alternate" type="text/html" title="Algorithm 완전 탐색에 관하여" /><published>2021-06-01T00:00:00+09:00</published><updated>2021-06-01T00:00:00+09:00</updated><id>https://sanseongko.github.io/algorithm-Exhaustive%20Search</id><content type="html" xml:base="https://sanseongko.github.io/algorithm-Exhaustive-Search">&lt;p&gt;오늘은 알고리즘 중 하나인 완전 탐색 알고리즘에 대하여 알아보려고 한다.&lt;/p&gt;

&lt;h3&gt;완전 탐색(Exhaustive Search)이란?&lt;/h3&gt;

&lt;p&gt;완전 탐색이란, 가능한 경우의 수를 모두 구하여 답을 찾는 &lt;b&gt;방법&lt;/b&gt;이다. 알고리즘이라고 하기 보단 답을 찾는 방법이라고 할 수 있다.
답을 찾는 방법이고 경우의 수가 너무나도 많아질 경우엔 모든 경우의 수를 확인하는 것은 너무 어렵기 때문에 완전 탐색에 주로 사용되는 알고리즘 기법들
또는 테크닉들이 있다.&lt;/p&gt;

&lt;h3&gt;사용되는 알고리즘 기법, 테크닉&lt;/h3&gt;

&lt;p&gt;완전 탐색의 경우 N의 크기가 작을 때, 시간 복잡도가 N의 지수승, 팩토리얼 꼴로 나올 때 많이 사용된다.&lt;/p&gt;

&lt;p&gt;&lt;b&gt;단순 탐색&lt;/b&gt;&lt;br /&gt;
알고리즘 기법을 사용하지 않고, 반복문과 조건문등을 이용하여 가능한 모든 경우를 만들어 답을 구하는 방법이다. 매우 비효율 적이기 때문에 가급적이면
쓰이지 않는다.&lt;/p&gt;

&lt;p&gt;&lt;b&gt;비트 마스크&lt;/b&gt;
&lt;br /&gt;
비트란, 컴퓨터에서 사용되는 2진 숫자로 되어있는 최소 단위이다. 이러한 이진수를 기반으로 0이면 true 1이면 false 혹은 2진수를 십진수로 표한 하는
형태로 사용이 가능하다.
예를 들면, 배열이 있고 그 배열의 부분만 들어있는 배열이 있다고 해보면,&lt;/p&gt;
&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;},&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;},&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;},&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;부분 집합의 배열을 전체 배열에 인덱스에 비교하여 boolean형태의 배열을 만들 수도 있다(ex.{1,2,3} =&amp;gt; {1,1,1,0,0}). 하지만 이럴 경우 많은 메모리
사용과 오버헤드를 증가시킬 수 있다. 따라서, 비트마스크를 이용하여 정수형태로 나타낼 수 있다.
{1,2,3,4,5} =&amp;gt; 11111(2) =&amp;gt; 31&lt;br /&gt;
{1,2,3} =&amp;gt; 11100(2) =&amp;gt; 28&lt;br /&gt;
{2,4,5} =&amp;gt; 01011(2) =&amp;gt; 11&lt;br /&gt;
{1,2} =&amp;gt; 11000(2) =&amp;gt; 24&lt;br /&gt;
{4,5} =&amp;gt; 00011(2) =&amp;gt; 3&lt;br /&gt;
이렇다고 한다면 {1,2,3}의 부분 집합의 배열은 28의 정수형태로 표현이 가능하다는 말이다.&lt;/p&gt;

&lt;p&gt;&lt;b&gt;재귀 함수&lt;/b&gt;
&lt;br /&gt;
재귀 함수란 메소드에서 자기 자신을 다시 호출하여 작업을 수행하는 방식의 함수를 의미한다. 이렇듯, 같은 함수를 자기 자신이 계속해서 호출하여 모든 탐색을
진행할 수 있다는 것과 동일하다. 다만, 메모리를 많이 차지하기 때문에 성능이 반복문에 비하여 느리고, 적절히 빠져나오지 못하게 만든다면, 무한히 호출하기
때문에 코드를 짤 때 유의 해줘야한다.&lt;/p&gt;

&lt;p&gt;&lt;b&gt;순열&lt;/b&gt;
&lt;br /&gt;
순열이란 서로 다른 n개의 집합에서 순서대로 늘어놓은 경우의 수를 얘기하며, 완전 탐색의 대표적인 유형이다. 또한, 재귀 함수를 이용하여 수를 채워나가지만,
n이 커질 수록 처리시간이 길어지므로, n이 크기가 작아야한다. 
&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;b&gt;BFS(너비 우선 탐색)/DFS(깊이 우선 탐색)&lt;/b&gt;알고리즘도 같이 사용되긴하지만, 따로 다룰 생각이므로 다음 포스팅에서 소개하려고 한다.&lt;/p&gt;</content><author><name>Ko</name></author><category term="algorithm" /><summary type="html">오늘은 알고리즘 중 하나인 완전 탐색 알고리즘에 대하여 알아보려고 한다.</summary></entry><entry><title type="html">Algorithm 정렬에 관하여</title><link href="https://sanseongko.github.io/algorithm-sort" rel="alternate" type="text/html" title="Algorithm 정렬에 관하여" /><published>2021-05-31T00:00:00+09:00</published><updated>2021-05-31T00:00:00+09:00</updated><id>https://sanseongko.github.io/algorithm-sort</id><content type="html" xml:base="https://sanseongko.github.io/algorithm-sort">&lt;p&gt;오늘은 정렬의 종류와 각 종류의 장단점에 대하여 알아보려한다. &lt;br /&gt;
여러가지 정렬이 있지만 기본적으로 그리고 내가 알고 싶은 정렬에 대하여 알아보려한다.&lt;/p&gt;

&lt;h3&gt;선택 정렬(Selection Sort)&lt;/h3&gt;
&lt;p&gt;선택 정렬은 집합 내에서 가장 작은 수를 선택하고 교환하는 것을 반복하는 정렬이다.
&lt;img src=&quot;./assets/built/images/algorithm/sort/selectionsort.png&quot; alt=&quot;ex_screenshot&quot; /&gt;
처음 인덱스에서 제일 작은 수를 찾아 교환하게 된다. 그 이후 비교하는 수의 인덱스를 하나씩 늘려가며 작은 수를 찾는 것을 반복한다.
&lt;br /&gt;
선택 정령은 구현이 쉬운 편에 속하며, 비교 횟수는 많지만 교환 횟수는 적기 때문에 많은 교환이 자료 상태에서 효율적으로 사용된다.&lt;/p&gt;

&lt;h3&gt;삽입 정렬(Insertion Sort)&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;./assets/built/images/algorithm/sort/insertionsort.png&quot; alt=&quot;ex_screenshot&quot; /&gt;&lt;/p&gt;

&lt;p&gt;사진과 함께 이해하면 쉽다. 선택된 수와 그 수의 왼쪽과 비교하여 선택된 수보다 작은 수가 나올 때까지 정렬하는 방법이다.&lt;/p&gt;

&lt;h3&gt;버블 정렬(Bubble Sort)&lt;/h3&gt;
&lt;p&gt;버블 정렬은 선택된 값의 좌측 값이 선택된 값보다 크다면 교환하는 방법을 말한다.
좌측 값만 비교하면 되기 때문에 구현이 단순하다.
&lt;img src=&quot;./assets/built/images/algorithm/sort/bubblesort.png&quot; alt=&quot;ex_screenshot&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;b&gt;선택 정렬, 삽입 정렬, 버블 정렬 모두 O(N^2)의 시간 복잡도를 가지고 있다. 다만 실제로는, 선택 정렬이 버블 정렬보다 조금 더 빠르다. 또한,
삽입 정렬의 경우 최선의 경우엔 O(N)의 시간복잡도를 가져 굉장히 빠른 정렬 방법이 될 수 있고, 이러한 이유로 다른 정렬 알고리즘의 일부로 사용되기도 한다.&lt;/b&gt;&lt;/p&gt;

&lt;h3&gt;쉘 정렬(Shell Sort)&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;./assets/built/images/algorithm/sort/shellsort.png&quot; alt=&quot;ex_screenshot&quot; /&gt;&lt;/p&gt;

&lt;p&gt;쉘 정령은 선택 정렬과 개념이 같은데 차이가 있는 점은 쉘 정렬은 간격만큼 옆으로 이동한다는 것이다.
사진에서 보이듯 간격을 설정하고 그 간격의 크기를 줄여나가면서 정렬을 해나간다. 
시간복잡도는 평균 O(N^1.5)이자만 최악의 경우O(N^2)의 시간복잡도를 가지게 된다.&lt;/p&gt;

&lt;h3&gt;퀵 정렬(Quick Sort)&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;./assets/built/images/algorithm/sort/quicksort.png&quot; alt=&quot;ex_screenshot&quot; /&gt;
퀵 정렬은 축 값을 지정하고 그 축의 촤측 처음 인덱스 부터 오른쪽으로 이동하며, 자신보다 크거나 같은 값을 비교하여 교환하고 우측 끝 인덱스 부터 왼
쪽으로 이동하며, 자신보다 작거나 같은 값을 비교하여 교환한다. 그 이후 사진에서 보이는 대로 left 인덱스가 right 인덱스보다 크다면 처음 배열을 분할한다.
배열이 분리되면 축 값을 다시 잡고 위의 과정을 반복하여 정렬한다.
시간 복잡도에서는 보통 O(NlogN)으로 실행 시간이 준수한 편이지만, 축값에 따라서 시간복잡도가 크게 달라지며, 최악(역순)일 경우 O(N^2)의 시간 복잡
도를 가지기 때문에 축 값을 잘 지정하는 것이 좋다.&lt;/p&gt;

&lt;h3&gt;병합 정렬(Merge Sort)&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;./assets/built/images/algorithm/sort/mergesort.png&quot; alt=&quot;ex_screenshot&quot; /&gt;
병합 정렬은 분할할 부분의 값을 정하고 그 부분을 기준으로 최소 단위까지 나누어 병합시에 각 부분을 순차 비교 후 임시 배열에 삽입하고, 원래 배열에 
임시 배열을 넣어준다. 이 과정을 반복하는 것이 병합 정렬이다.
퀵 정렬과 비슷하게 원래 배열을 나누어 정렬하는 정렬 법이다. 그렇기 때문에 분할하는 과정에서 logN만큼의 시간이 걸리고 결국 O(NlogN)의 시간 복잡도를
가지게 된다. 다만, 퀵 정렬과 달리 분할해줘야 하는 기준점 설정없이 절반으로 나누어 분할하기 때문에 기준점에 따라 시간이 증가하거나 줄어들지 않는다.
따라서 항상 같은 시간복잡도를 가지게 되고 안정성이 있기 때문에, 정렬법들중 준수한 정렬 법이다. 
하지만, 분할하여 임시배열에 배열을 분할된 배열을 저장하다보니, 추가적인 메모리가 필요하고, 이를 기준으로 퀵을 써야할지 병합을 써야할지 기준을 정하면 된다.&lt;/p&gt;

&lt;h3&gt;힙 정렬(Heap Sort)&lt;/h3&gt;
&lt;p&gt;힙정렬은 힙알고리즘을 기본으로 짜여진 정렬이다. 그렇다면 루트 노드에는 항상 제일 우선순위인 값이 삽입되어 있을 것이다. 그렇다면 그 루트를 출력하고
힙에서 제거한다. 이 과정을 반복하여 정렬하는 방법이다.
힙 정렬은 추가적인 메모리를 필요로 하지 않기 때문에, 항상 O(NlogN)의 시간 복잡도를 보여준다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;
출처: https://namu.wiki/w/%EC%A0%95%EB%A0%AC%20%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98&lt;br /&gt;
출처: https://yabmoons.tistory.com/250 [얍문’s Coding World..]&lt;br /&gt;
출처: https://roka88.dev/98 [이병록의 개발 블로그]&lt;br /&gt;&lt;/p&gt;</content><author><name>Ko</name></author><category term="algorithm" /><summary type="html">오늘은 정렬의 종류와 각 종류의 장단점에 대하여 알아보려한다. 여러가지 정렬이 있지만 기본적으로 그리고 내가 알고 싶은 정렬에 대하여 알아보려한다.</summary></entry><entry><title type="html">Java RESTful API 개념 정리</title><link href="https://sanseongko.github.io/java-restapi" rel="alternate" type="text/html" title="Java RESTful API 개념 정리" /><published>2021-05-30T00:00:00+09:00</published><updated>2021-05-30T00:00:00+09:00</updated><id>https://sanseongko.github.io/java-restapi</id><content type="html" xml:base="https://sanseongko.github.io/java-restapi">&lt;p&gt;오늘은 RESTful API에 대하여 정리해보려고 한다.
RESTful API를 알기전에 REST와 RESTful의 차이를 알아야 한다.
REST란, 분산시스템 설계를 위한 &lt;b&gt;아키텍처 스타일&lt;/b&gt;이다. 즉, 제약 조건의 집합이라고 볼 수 있다. 
그렇다면, RESTful은 무엇일까? RESTful은 제약조건의 집합 즉, 아키텍처 스타일, 아키텍처 원칙을 모두 만족하는 것을 의미한다.&lt;/p&gt;

&lt;h3&gt;RESTful API&lt;/h3&gt;
&lt;p&gt;RESTful API는 REST 아키텍처 원칙을 모두 만족하는 API라고 할 수 있다.
또한, 인터넷과 웹을 통해 나의 컴퓨터를 제어할때 어떻게하면 시행착오를 줄이고 더 좋은 API를 만들수 있는가에 대한 고민이다.
RESTful API는 특정기술 지칭하는 것이 아니라, HTTP를 이용하여 기계들이 통신할때 HTTP가 가진 잠재력을 최대한 끌어낼 수 있는 모범사례라고 할 
수 있다. 
HTTP메서드들을 본래 용도에 맞게 쓰자는 것도 중요한 목적&lt;/p&gt;

&lt;h3&gt;RESTful API의 구성요소&lt;/h3&gt;
&lt;p&gt;&lt;b&gt;Resource(자원)&lt;/b&gt;
데이터들을 Resource라고 하고, REST API는 URI(정보를 식별하는 이름일뿐) 로 표현된다.
Collection : Element 의 집합(복수형)
Element: 콜렉션에서 하나하나의 데이터(단수형)
URI를 가공하는 방법&lt;/p&gt;

&lt;p&gt;&lt;b&gt;Method(행위)&lt;/b&gt;
또한, 보통의 웹페이지간의 데이터 전송은 Post로 이루어지는 경우가 많다. REST는 HTTP메소드를 최대한 활용하는 아키텍처 스타일이다.
그렇기 때문에, REST는 HTTP메소드를 알맞은 곳에 사용하기를 원한다. 밑의 내용은 HTTP메소드의 원래의 기능을 알려준다.&lt;/p&gt;

&lt;p&gt;&lt;b&gt;Create -&amp;gt; post&lt;br /&gt;
Read -&amp;gt; get&lt;br /&gt;
Update -&amp;gt; put(전체), patch(부분)&lt;br /&gt;
Delete -&amp;gt; delete&lt;br /&gt;&lt;b&gt;
&lt;a href=&quot;https://github.com/Microsoft/api-guidelines/blob/vNext/Guidelines.md&quot;&gt;Microsoft REST API Guidelines&lt;/a&gt;에서는 HEAD와 OPTIONS메소드도 알려주고 있다.
HEAD는 READ(GET) 응답을 위해 객체의 메타데이터를 리턴해주는 것이며, OPTION은 요청 정보를 얻는 것 즉, 도움말 정도로 볼 수 있을 것 같다. 
여기서 put과 patch의 방식이 조금 혼동될 수 있지만, patch는 다른 데이터에 영향을 주지 않고 해당 데이터만 변한다면, put은 변경하려는 데이터를
제외하고는 삭제가 되는 차이를 예로 들 수 있다.(patch는 부분을 수정, put은 전체 수정)&lt;/b&gt;&lt;/b&gt;&lt;/p&gt;

&lt;h3&gt;REST 특징(제약 조건)&lt;/h3&gt;
&lt;p&gt;&lt;b&gt;Server-Client(서버-클라이언트 구조)&lt;/b&gt;
    REST서버는 API를 제공, Client는 사용자 인증이나 세션,로그인 정보등을 직접 관리하는 구조로 서버와 클라이언트 사이의 역할이 확실히 구분됨
    그로인하여, 개발할 내용이 명확해지고 서로간 의존성이 줄어들게 된다.
&lt;b&gt;Stateless(무상태성)&lt;/b&gt;
작업을 위한 상태정보를 따로 저장하거나 관리하지 않는다. 따라서 들어오는 요청을 단순히 처리만 하면된다. 이로인하여 서비스의 자유도가 상승 서버의
불필요한 정보를 관리하지 않기 때문에 구현이 단순해진다.
&lt;br /&gt;
&lt;b&gt;Cacheable(캐시 처리 가능)&lt;/b&gt;
HTTP의 기존 웹표준을 그대로 이용하기 때문에, 웹에서 사용하는 기존 인프라를 그대로 활용이 가능하다. 따라서 HTTP의 캐싱기능을 적용할 수 있는 것이
다. (캐싱구현은 HTTP표준에서 사용하는 Last-Modified태그나 E-Tag를 이용하면 캐싱 구현이 가능하다.)
&lt;br /&gt;
&lt;b&gt;Layered System(계층형 구조)&lt;/b&gt;
REST 서버는 다중 계층으로 구성될 수 있으며 보안, 로드 밸런싱, 암호화 계층을 추가해 구조상의 유연성을 둘 수 있고 PROXY, 게이트웨이 같은 네트워
크 기반의 중간매체를 사용할 수 있게한다.
&lt;br /&gt;
&lt;b&gt;Uniform Interface(인터페이스 일관성)&lt;b&gt;
Uniform Interface는 URI로 지정한 리소스에 대한 조작을 통일되고 한정적인 인터페이스로 수행하는 아키텍처 스타일을 말한다.
&lt;br /&gt;
&lt;b&gt;Self-descriptiveness&lt;/b&gt;
REST API의 메세지만 보고도 이를 쉽게 이해할 수 있는 자체 표현 구조로 되어 있다.
&lt;br /&gt;&lt;/b&gt;&lt;/b&gt;&lt;/p&gt;

&lt;추가적인 내용은=&quot;&quot; 더욱=&quot;&quot; 이후=&quot;&quot; REST=&quot;&quot; API를=&quot;&quot; 만들다가=&quot;&quot; 보충될게=&quot;&quot; 있으면=&quot;&quot; 더=&quot;&quot; 보충=&quot;&quot;&gt;



출처
[정아마추어 코딩블로그](https://jeong-pro.tistory.com/180#:~:text=REST%EB%8A%94%20%EB%B6%84%EC%82%B0%20%EC%8B%9C%EC%8A%A4%ED%85%9C%20%EC%84%A4%EA%B3%84,%EB%A7%8C%EC%A1%B1%ED%95%98%EB%8A%94%20%EA%B2%83%EC%9D%84%20%EC%9D%98%EB%AF%B8%ED%95%9C%EB%8B%A4.)
https://gmlwjd9405.github.io/2018/09/21/rest-and-restful.html/rest-and-restful.html
https://meetup.toast.com/posts/92
[생활코딩님의 기계들의 대화법 - REST API](https://www.youtube.com/watch?v=PmY3dWcCxXI)
&lt;/추가적인&gt;</content><author><name>Ko</name></author><category term="java" /><summary type="html">오늘은 RESTful API에 대하여 정리해보려고 한다. RESTful API를 알기전에 REST와 RESTful의 차이를 알아야 한다. REST란, 분산시스템 설계를 위한 아키텍처 스타일이다. 즉, 제약 조건의 집합이라고 볼 수 있다. 그렇다면, RESTful은 무엇일까? RESTful은 제약조건의 집합 즉, 아키텍처 스타일, 아키텍처 원칙을 모두 만족하는 것을 의미한다.</summary></entry></feed>