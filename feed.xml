<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.9.0">Jekyll</generator><link href="https://sanseongko.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="https://sanseongko.github.io/" rel="alternate" type="text/html" /><updated>2021-05-30T00:04:42+09:00</updated><id>https://sanseongko.github.io/feed.xml</id><title type="html">SanseongKo’s Blog</title><subtitle>온리 공부를 위한 블로그</subtitle><entry><title type="html">Algorithm Heap에 관하여</title><link href="https://sanseongko.github.io/algorithm-heap" rel="alternate" type="text/html" title="Algorithm Heap에 관하여" /><published>2021-05-28T00:00:00+09:00</published><updated>2021-05-28T00:00:00+09:00</updated><id>https://sanseongko.github.io/algorithm-heap</id><content type="html" xml:base="https://sanseongko.github.io/algorithm-heap">&lt;p&gt;오늘은 자료구조 힙에 관하여 알아보자.&lt;/p&gt;

&lt;h3&gt;완전 이진 트리&lt;/h3&gt;
&lt;p&gt;힙 자료구조를 알아보기 전에 완전 이진 트리에 관하여 알아둬야 할 필요가 있다. 
완전 이진 트리란 이진 트리증 왼쪽부터 차례대로 채워져 있는 트리를 의미한다. 사진으로 보면 더욱 쉽게 이해가 가능하다.
&lt;img src=&quot;./assets/built/images/algorithm/heap/binarytree.png&quot; alt=&quot;ex_screenshot&quot; /&gt;&lt;/p&gt;

&lt;p&gt;위 사진에서 왼쪽은 왼쪽부터 차례대로 채워져 있는 상태이므로 완전 이진 트리라 할 수 있으며, 사진의 오른쪽은 왼쪽 노드가 다 채워져 있지 않은 상태
이기 때문에 완전 이진 트리가 아니다.&lt;/p&gt;

&lt;h3&gt;힙(Heap) 자료구조&lt;/h3&gt;
&lt;p&gt;자료 구조 힙이란, 완전 이진 트리의 일종으로 우선순위 큐를 구현할때 자주 사용되는 알고리즘이다. 또한, 여러개의 값들 중 최댓값이나 최솟값을 빠르게
찾아낼 수 있도록 만들어진 자료구조이다. 힙은 일종의 반정렬 상태를 유지하며, 중복된 값을 허용한다.&lt;/p&gt;

&lt;p&gt;힙에서 부모 노드와 자식 노드의 관계는 아래의 규칙을 따른다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;왼쪽 자식의 인덱스 = (부모의 인덱스)*2&lt;/li&gt;
  &lt;li&gt;오른쪽 자식의 인덱스 = (부모의 인덱스)*2+1&lt;/li&gt;
  &lt;li&gt;부모의 인덱스 = (자식의 인덱스)/2
&lt;img src=&quot;./assets/built/images/algorithm/heap/heapnode.png&quot; alt=&quot;ex_screenshot&quot; /&gt;
&lt;b&gt;힙의 종류&lt;/b&gt;
-최대 힙
    &lt;ul&gt;
      &lt;li&gt;부모 노드의 키 값이 자식 노드의 키 값보다 크거나 같은 완전 이진트리를 의미한다.
-최소 힙&lt;/li&gt;
      &lt;li&gt;부모 노드의 키 값이 자식 노드의 키 값보다 작거나 같은 완전 이진 트리를 의미한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;./assets/built/images/algorithm/heap/heaptree.png&quot; alt=&quot;ex_screenshot&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;b&gt;힙의 삽입 과정&lt;/b&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;힙에 새로운 요소가 들어오면, 힙의 마지막 노드에 이어서 삽입하게 된다.&lt;/li&gt;
  &lt;li&gt;새로운 노드를 부모노드들과 교환하여 힙의 성질을 만족시킨다.
아래의 과정으로 확인할 수 있다.
&lt;img src=&quot;./assets/built/images/algorithm/heap/heapprogress.PNG&quot; alt=&quot;ex_screenshot&quot; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;b&gt;힙의 삭제 과정&lt;/b&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;최대 힙에서 최대값은 루트 노드(1번노드)이므로 루트노드가 삭제된다&lt;/li&gt;
  &lt;li&gt;삭제된 루트 노드엔 힙의 가장 마지막 노드를 가져와서 위치 시킨 뒤&lt;/li&gt;
  &lt;li&gt;자식 노드들과 비교하여 힙을 재구성한다.
아래의 과정으로 확인할 수 있다.
&lt;img src=&quot;./assets/built/images/algorithm/heap/heapdelete.PNG&quot; alt=&quot;ex_screenshot&quot; /&gt;&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Ko</name></author><category term="algorithm" /><summary type="html">오늘은 자료구조 힙에 관하여 알아보자.</summary></entry><entry><title type="html">Algorithm Stack and Queue에 관하여</title><link href="https://sanseongko.github.io/algorithm-stackqueue" rel="alternate" type="text/html" title="Algorithm Stack and Queue에 관하여" /><published>2021-05-27T00:00:00+09:00</published><updated>2021-05-27T00:00:00+09:00</updated><id>https://sanseongko.github.io/algorithm-stackqueue</id><content type="html" xml:base="https://sanseongko.github.io/algorithm-stackqueue">&lt;p&gt;오늘은 스택과 큐라는 알고리즘을 알아보도록 하겠다. 
스택과 큐를 같이 묶어서 포스팅하는 이유는 비슷한 느낌이자만 차이가 분명하게 존재하기 때문이다.&lt;/p&gt;

&lt;h3&gt;스택(Stack)이란?&lt;/h3&gt;
&lt;p&gt;스택은 Last In First Out (LIFO), 즉 &lt;b&gt;후입선출&lt;/b&gt;구조를 가지고 있다.
또한, 한쪽에서 삽입과 삭제가 이루어 지는 구조이기도 하다.
&lt;img src=&quot;./assets/built/images/algorithm/stackqueue/stack.png&quot; alt=&quot;ex_screenshot&quot; /&gt;
위의 사진은 흔히 볼 수 있는 스택의 형태를 가지고 있고, push는 자료의 삽입, pop은 자료의 배출이라고 보면 된다. 사진에서도 볼 수 있듯 한쪽에서 
삽입되고, 한 쪽에서 삭제가 되는 것을 볼 수가 있다.&lt;/p&gt;

&lt;p&gt;&lt;b&gt;그럼 스택은 어디서 쓰일까?&lt;b&gt; 예를 들자면, 브라우저의 뒤로가기 버튼을 생각하면된다. 가장 마지막에 거쳐온 곳을 보여줘야하니 제일 마지막의 정보를
제일 처음 보여준다와 의미가 통한다.&lt;/b&gt;&lt;/b&gt;&lt;/p&gt;

&lt;h3&gt;큐(Queue)란?&lt;/h3&gt;
&lt;p&gt;큐는 스택과 다르게 First In First Out(FIFO) 즉, &lt;b&gt;선입선출&lt;/b&gt;구조를 가지고 있다. 스택은 한쪽에서 삽입과 삭제가 일어난다고 했는데, 그렇다면 큐는?
큐는 제일 먼저들어간 것이 제일 처음 나오게 되므로, 삽입되는 곳에서는 이미 마지막으로 들어온 것이 버티고 있어 나가지 못한다. 그렇기 때문에 한쪽 끝(front)에서
삽입되어 다른 쪽 끝(rear)에서 삭제된다.
&lt;img src=&quot;./assets/built/images/algorithm/stackqueue/queue.png&quot; alt=&quot;ex_screenshot&quot; /&gt;
사진으로 보아도 스택과는 다르게 push되는 곳과 pop되는 곳의 위치가 다른 것을 확인할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;b&gt;그럼 큐는 어디서 쓰일까?&lt;b&gt; 예를 들자면, 대기줄이 필요할때 먼저온 사람이 먼저 정보를 받는 형태 또는 데이터 유입속도가 데이터 소모속도 보다
빠를때 쓰일 수 있다.&lt;/b&gt;&lt;/b&gt;&lt;/p&gt;

&lt;h3&gt;Java에서 Stack 사용법&lt;/h3&gt;
&lt;p&gt;Stack 선언&lt;/p&gt;
&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;java&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;util&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;Stack&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;Stack&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;stack&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Stack&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;elelment&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;//element는 스택에 담기는 자료형이 어떤 자료형인지&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Stack 값 삽입&lt;/p&gt;
&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nx&quot;&gt;stack&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;push&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;값&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Stack 값 삭제&lt;/p&gt;
&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nx&quot;&gt;stack&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;pop&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;//제일 마지막에 들어간 수 출력과 삭제&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;stack&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;clear&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;//스택에 저장되어 있는 전체 값 삭제&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Stack 처음 나올 값 확인&lt;/p&gt;
&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nx&quot;&gt;stack&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;peek&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;//값만 출력 삭제x&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Stack의 기타 메소드&lt;/p&gt;
&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nx&quot;&gt;stack&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;//스택의 크기 출력(ex.값이 2개들어 있다면 2를 출력)&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;stack&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;empty&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;//스택이 비어 있는지 체크&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;stack&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;contains&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;값&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;//스택에 해당 값이 있는지 체크(boolean으로 리턴)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3&gt;Java에서 Queue 사용법&lt;/h3&gt;
&lt;p&gt;Queue 선언&lt;/p&gt;
&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;java&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;util&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;LinkedList&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;java&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;util&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;Queue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;Queue&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;queue&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;LinkedList&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;elelment&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;//element는 큐에 담기는 자료형이 어떤 자료형인지&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;자바에서 큐는 LinkedList로 객체선언을 해주어야 사용이 가능함을 잊지말자.
Queue 값 삽입&lt;/p&gt;
&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nx&quot;&gt;queue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;offer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;값&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;//삽입에 성공하면 true를 반환하고, 큐에 여유 공간이 없어 삽입에 실패하면 IllegalStateException을 발생&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Queue 값 삭제&lt;/p&gt;
&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nx&quot;&gt;queue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;poll&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;//제일 마지막에 들어간 수 출력과 삭제(비어있다면 null)&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;queue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;remove&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;//큐에 첫번째 값 제거&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;queue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;clear&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;//큐 초기화&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Queue 처음 나올 값 확인&lt;/p&gt;
&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nx&quot;&gt;queue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;peek&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;//값만 출력 삭제x&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name>Ko</name></author><category term="algorithm" /><summary type="html">오늘은 스택과 큐라는 알고리즘을 알아보도록 하겠다. 스택과 큐를 같이 묶어서 포스팅하는 이유는 비슷한 느낌이자만 차이가 분명하게 존재하기 때문이다.</summary></entry><entry><title type="html">Java ORM이란?</title><link href="https://sanseongko.github.io/java-orm" rel="alternate" type="text/html" title="Java ORM이란?" /><published>2021-05-27T00:00:00+09:00</published><updated>2021-05-27T00:00:00+09:00</updated><id>https://sanseongko.github.io/java-orm</id><content type="html" xml:base="https://sanseongko.github.io/java-orm">&lt;p&gt;MyBatis를 사용하다가 ORM이라는 것을 듣게 되었다. 너무 궁금하니 한번 알아보자.&lt;/p&gt;

&lt;h3&gt;ORM이란?&lt;/h3&gt;
&lt;p&gt;Object Relational Mapping, 말 그대로 객체-관계 매핑이라는 것이다.
다만 RDB는 테이블로 이루어져 있고, OPP 객체지향 프로그래밍에서는 클래스를 사용하게 된다. 하지만 객체와 관계형 데이터베이스가 애초에 호환을 염두
하고 만들어 진 것이 아니다보니, 자연스럽게 불일치가 발생하게 된다. 
이럴때 ORM을 사용하여 객체의 관계를 바탕으로 SQL문을 자동적으로 생성 불일치를 해결한다.&lt;/p&gt;

&lt;p&gt;&lt;b&gt;객체 - 관계 간의 불일치&lt;b&gt;
그렇다면 객체-관계간의 불일치는 왜 생기게 될까? 이유는 5가지로 분류할 수 있다.
&lt;b&gt;1. 세분성(Granularity)&lt;/b&gt;
경우에 따라서 데이터베이스에 있는 테이블 수보다 &lt;b&gt;더 많은 클래스&lt;/b&gt;를 가진 모델이 생길 수 있다.
(RDB 데이터 타입은 Vendor마다 다르며, 더이상 정규화가 힘들다.)&lt;/b&gt;&lt;/b&gt;&lt;/p&gt;

&lt;p&gt;&lt;b&gt;2. 상속성(Inheritance)&lt;/b&gt;
RDBMS는 객체지향 프로그래밍 언어의 특징인 &lt;b&gt;상속 개념이 없다.&lt;/b&gt;&lt;/p&gt;

&lt;p&gt;&lt;b&gt;3. 일치(Identity)&lt;/b&gt;
RDBMS는 &lt;b&gt;기본키(primary key)&lt;/b&gt;를 이용하여 동일성을 정의한다. 그러나 자바는 객체 식별(a==b)과 객체 동일성(a.equals(b))을 모두 정의한다.&lt;/p&gt;

&lt;p&gt;&lt;b&gt;4. 연관성(Associations)&lt;/b&gt;
객체지향 언어는 방향성이 있는 &lt;b&gt;객체의 참조(reference)&lt;/b&gt;를 사용하여 연관성을 나타내지만 RDBMS는 방향성이 없는 외래키(foreign key)를 이용해서 나타낸다.&lt;/p&gt;

&lt;p&gt;&lt;b&gt;5. 탐색(Navigation)&lt;/b&gt;
자바와 RDBMS에서 객체를 접근하는 방법이 근본적으로 다르다. 자바는 그래프형태로 하나의 연결에서 다른 연결로 이동하며 탐색한다. 그러나 RDBMS에서는 
일반적으로 SQL문을 최소화하고 JOIN을 통해 여러 엔티티를 로드하고 원하는 대상 엔티티를 선택하는 방식으로 탐색한다.&lt;/p&gt;

&lt;h3&gt;ORM의 장점과 단점&lt;/h3&gt;
&lt;p&gt;&lt;b&gt;장점&lt;/b&gt;&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;객체 지향적인 코드로 인해 더 직관적이고 비즈니스 로직에 더 집중할 수 있게 도와준다.
    &lt;ul&gt;
      &lt;li&gt;선언문, 할당, 종료 같은 부수적인 코드가 없거나 급격히 줄어든다.&lt;/li&gt;
      &lt;li&gt;각종 객체에 대한 코드를 별도로 작성하기 때문에 코드의 가독성을 올려준다.&lt;/li&gt;
      &lt;li&gt;SQL의 절차적이고 순차적인 접근이 아닌 객체 지향적인 접근으로 인해 생산성이 증가한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;재사용 및 유지보수의 편리성이 증가한다.
    &lt;ul&gt;
      &lt;li&gt;ORM은 독립적으로 작성되어있고, 해당 객체들을 재활용 할 수 있다.&lt;/li&gt;
      &lt;li&gt;때문에 모델에서 가공된 데이터를 컨트롤러에 의해 뷰와 합쳐지는 형태로 디자인 패턴을 견고하게 다지는데 유리하다.&lt;/li&gt;
      &lt;li&gt;매핑정보가 명확하여, ERD를 보는 것에 대한 의존도를 낮출 수 있다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;DBMS에 대한 종속성이 줄어든다.
    &lt;ul&gt;
      &lt;li&gt;대부분 ORM 솔루션은 DB에 종속적이지 않다.&lt;/li&gt;
      &lt;li&gt;종속적이지 않다는것은 구현 방법 뿐만아니라 많은 솔루션에서 자료형 타입까지 유효하다.&lt;/li&gt;
      &lt;li&gt;프로그래머는 Object에 집중함으로 극단적으로 DBMS를 교체하는 거대한 작업에도 비교적 적은 리스크와 시간이 소요된다.&lt;/li&gt;
      &lt;li&gt;또한 자바에서 가공할경우 equals, hashCode의 오버라이드 같은 자바의 기능을 이용할 수 있고, 간결하고 빠른 가공이 가능하다.
&lt;b&gt;단점&lt;/b&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;완벽한 ORM 으로만 서비스를 구현하기가 어렵다.
    &lt;ul&gt;
      &lt;li&gt;사용하기는 편하지만 설계는 매우 신중하게 해야한다.&lt;/li&gt;
      &lt;li&gt;프로젝트의 복잡성이 커질경우 난이도 또한 올라갈 수 있다.&lt;/li&gt;
      &lt;li&gt;잘못 구현된 경우에 속도 저하 및 심각할 경우 일관성이 무너지는 문제점이 생길 수 있다.&lt;/li&gt;
      &lt;li&gt;일부 자주 사용되는 대형 쿼리는 속도를 위해 SP를 쓰는등 별도의 튜닝이 필요한 경우가 있다.&lt;/li&gt;
      &lt;li&gt;DBMS의 고유 기능을 이용하기 어렵다. (하지만 이건 단점으로만 볼 수 없다 : 특정 DBMS의 고유기능을 이용하면 이식성이 저하된다.)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;프로시저가 많은 시스템에선 ORM의 객체 지향적인 장점을 활용하기 어렵다.
    &lt;ul&gt;
      &lt;li&gt;이미 프로시저가 많은 시스템에선 다시 객체로 바꿔야하며, 그 과정에서 생산성 저하나 리스크가 많이 발생할 수 있다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;br /&gt;
결국 편하자고 사용하는 것이고, 객체지향다운 프로그래밍을 하자는 것이다. 다만, 장점과 단점에서 보았듯이, 원래 OOP와 RDB가 서로를 위하여 만들어 
진 것이 아닌 만큼 ORM을 사용하는 framework들을 사용하는 것도 좋지만, 정확하게 알고 사용해야 하고, 추가적으로 ORM의 한계 혹은 성능저하가 일어
나는 부분에 대하연 추가적인 공부 및 알게된다면 다시 추가 포스팅을 해야할 것 같다.&lt;/p&gt;

&lt;p&gt;출처 
https://geonlee.tistory.com/207 [빠리의 택시 운전사]
&lt;a href=&quot;http://www.incodom.kr/ORM#h_702209f3f35878a32ee91352ddc6bbe7&quot;&gt;장점과 단점&lt;/a&gt;&lt;/p&gt;</content><author><name>Ko</name></author><category term="java" /><summary type="html">MyBatis를 사용하다가 ORM이라는 것을 듣게 되었다. 너무 궁금하니 한번 알아보자.</summary></entry><entry><title type="html">Java JPA란?</title><link href="https://sanseongko.github.io/java-jpa" rel="alternate" type="text/html" title="Java JPA란?" /><published>2021-05-27T00:00:00+09:00</published><updated>2021-05-27T00:00:00+09:00</updated><id>https://sanseongko.github.io/java-jpa</id><content type="html" xml:base="https://sanseongko.github.io/java-jpa"></content><author><name>Ko</name></author><category term="java" /><summary type="html"></summary></entry><entry><title type="html">Java .equals(), hashcode(), ==의 차이점</title><link href="https://sanseongko.github.io/java-evshash" rel="alternate" type="text/html" title="Java .equals(), hashcode(), ==의 차이점" /><published>2021-05-26T00:00:00+09:00</published><updated>2021-05-26T00:00:00+09:00</updated><id>https://sanseongko.github.io/java-evshash</id><content type="html" xml:base="https://sanseongko.github.io/java-evshash">&lt;p&gt;오늘은 많이 쓰지만 그래서 이게 뭐가 다르지 했던 ==연산자와 equals()메소드와 hashcode()메소드의 차이에 대하여 알아볼까?
&lt;img src=&quot;./assets/built/images/holololol.jpg&quot; alt=&quot;ex_screenshot&quot; /&gt;호롤ㄹ로로ㄹㄹㄹ&lt;/p&gt;

&lt;p&gt;&lt;b&gt;1. 자바에서의 ==연산자&lt;/b&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;==연산자는 비교하는 값이 primitive type(int, double, boolean 등등) 일때는 값이 같은지 비교 하고 
그 외의 객체, reference type(Array, Class 등등)일 때는 가리키는 주소가 같은지 비교하고 리턴값은 같으면 true, 다르면 false이다.
&lt;script src=&quot;https://gist.github.com/sanseongKo/77d01a930ab98c5fc2c1cd3eb5eb56e5.js&quot;&gt;&lt;/script&gt;
위와 같이 String으로 변수 선언할 경우 reference type이지만 메모리의 힙영역에 “String”이라는 값이 할당되고 a,b모두 할당된 주소 값을 참조하
기 때문에 true가 반환된다.&lt;/p&gt;
&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nb&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;하지만 위의 코드와 같이 생성자를 이용하여 각 a,b가 각 각각 따로 힙영역에 값을 할당 받을 경우 주소 값이 다르기 때문에 false가 출력된다.
배열의 경우에도 안의 내용이 같더라도 힙영역에 따로 선언되기 때문에 false가 출력된다.&lt;/p&gt;

&lt;p&gt;이와 같이, primitive type일땐 값을 비교, reference type일땐 힙영역에 할당된 주소 값을 비교한다.&lt;/p&gt;

&lt;p&gt;&lt;b&gt;2. 자바에서의 .equals()&lt;/b&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;equals() 메소드(Object 클래스의 메소드)의 경우 쉽게 말하면 내용을 비교한다.(배열의 경우 위의 코드에서 array1.equals(array2)라하면 false
가 나온다)
정확하게는 equals메소드에 정의되어 있는 내용대로 값들을 비교해 나간다. 스트링의 equals메소드에 대한 글은 &lt;a href=&quot;https://sas-study.tistory.com/280&quot;&gt;코딩하는 흑구&lt;/a&gt;
이분이 정리를 잘해주신 것 같다. 배열의 경우 Arrays 클래스를 import하여 그 안에 있는 equals메소드를 써야한다.
다만, 내용이 동일하더라도 안에 값이 같은지 확인을 못할 경우가 있다.
예를 들면,&lt;/p&gt;
&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kr&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Person&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kr&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kr&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;age&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    
    &lt;span class=&quot;kr&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;getName&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;kr&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;setName&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;kr&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;getAge&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;age&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;kr&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;setAge&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;age&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;age&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;age&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;kr&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Person&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;age&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;super&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;age&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;age&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;nd&quot;&gt;Override&lt;/span&gt;
    &lt;span class=&quot;kr&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;toString&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;Person [name=&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;, age=&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;age&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;이렇게 Person객체를 만들어 아래 정보를 삽입하였다면,&lt;/p&gt;
&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nx&quot;&gt;Person&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;person1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Person&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;27&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;Person&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;person2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Person&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;27&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;person1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;person2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;//false&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;person1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;equals&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;person2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;//false&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;person1 == person2는 당연히 false가 나올 것이지만, person.equals(person2)도 false가 나오게 된다. 이는 안의 내용중 name만 맞아도 같은 것으로
봐야하는지 아니면 27까지도 같이 확인을 해야하는지 모르기 때문이다. 이럴 경우에 equals메소드를 오버라이딩하여 다시 정의 해주도록 하자.&lt;/p&gt;

&lt;p&gt;&lt;b&gt;3. 자바에서의 .hashCode()&lt;/b&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;equals메소드하면 항상 같이 나오는 것이 hashCode()이다. 왜냐하면, 안에 내용이 같더라도 각 객체의 해시코드가 다를 경우가 있기 때문이다. 예를들어,
위의 경우에서 equals를 다시 정의하여 같은 값으로 볼 수 있게 정의하였다고 하여도 hash함수를 쓰는 객체가 있다면, 이를 다른 객체로 볼 수 있기 때문이다.
예를 들어, HashSet은 중복을 제거하고 저장해주는 클래스이다. 하지만 person1과 person2를 HashSet안에 담을 경우 해쉬코드가 다르기 때문에 다른 객체라고
판단, 따로 담아 저장해둔다. 이럴 경우도 대비하여 equals메소드를 오버라이딩할때 HashCode도 같이 재정의하여 문제가 없도록 하여야 한다.&lt;/p&gt;

&lt;p&gt;출처
https://jeong-pro.tistory.com/172 [기본기를 쌓는 정아마추어 코딩블로그]
https://sas-study.tistory.com/280 [코딩하는 흑구]&lt;/p&gt;</content><author><name>Ko</name></author><category term="java" /><summary type="html">오늘은 많이 쓰지만 그래서 이게 뭐가 다르지 했던 ==연산자와 equals()메소드와 hashcode()메소드의 차이에 대하여 알아볼까? 호롤ㄹ로로ㄹㄹㄹ</summary></entry><entry><title type="html">첫 포스팅!</title><link href="https://sanseongko.github.io/newPosting" rel="alternate" type="text/html" title="첫 포스팅!" /><published>2021-05-25T00:00:00+09:00</published><updated>2021-05-25T00:00:00+09:00</updated><id>https://sanseongko.github.io/newPosting</id><content type="html" xml:base="https://sanseongko.github.io/newPosting">&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;

&lt;p&gt;우역곡절 끝에 지킬을 이용하여 깃허브 블로그 페이지를 만들었다.(travis ci는 하다가 포기…)&lt;/p&gt;

&lt;p&gt;공부를 하다보니 까먹는게 너무 많아지고 알았던 개념도 까먹는 상황이 너무 빈번해지다보니, 
그리고 히키코모리마냥 혼자 정리된 문서를 가지고 있는 것 보단 블로그하나 만들어서 거기에 전부 담으면서 정리하는게 나아 보였다.&lt;/p&gt;

&lt;p&gt;점차 나아지는 부분도 눈으로 보일테니 더욱 좋아보인다.&lt;/p&gt;

&lt;p&gt;자, 이제 공부만을 위한 포스팅을 시작해야지 끌끌.&lt;/p&gt;</content><author><name>Ko</name></author><summary type="html"></summary></entry><entry><title type="html">Algorithm Hash에 관하여</title><link href="https://sanseongko.github.io/algorithm-hash" rel="alternate" type="text/html" title="Algorithm Hash에 관하여" /><published>2021-05-25T00:00:00+09:00</published><updated>2021-05-25T00:00:00+09:00</updated><id>https://sanseongko.github.io/algorithm-hash</id><content type="html" xml:base="https://sanseongko.github.io/algorithm-hash">&lt;p&gt;오늘은 Hash에 대하여 정리를 해보려고 한다.&lt;/p&gt;

&lt;p&gt;주 언어가 Java이다보니 HashMap은 많이 써보았지만, 정확하게 정리를 해본적은 없는 듯하여 정리를 해보려한다.&lt;/p&gt;

&lt;p&gt;내가 알고 있던 Hash에선 키와 값이 있으며, 키를 인덱스로 가지고 있기 때문에 시간복잡도가 O(1)이라는 것.&lt;/p&gt;

&lt;h3&gt;1 해시&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;해시는 임의의 크기를 가진 데이터를 고정된 데이터 크기로 변화시키는 것을 말하며,&lt;/li&gt;
  &lt;li&gt;해시함수를 사용하여 값을 계산하여 나온 고정된 길이의 값을 해시값이라고 부른다.&lt;/li&gt;
  &lt;li&gt;여러 분야에 사용되며, 복잡하지 않은 알고리즘으로 이루어져 CPU,메모리 등 시스템 자원을 덜 소모한다고 한다.&lt;/li&gt;
  &lt;li&gt;여러분야 사용되고 여러가지(MDn, SHA-n 등) 해시 알고리즘이 있지만(자세하게 다룰일이 있으면 추가해야지)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;./assets/built/images/algorithm/hash/hash_hash.png&quot; alt=&quot;ex_screenshot&quot; /&gt;&lt;/p&gt;

&lt;h3&gt;2 해시 충돌&lt;/h3&gt;
&lt;p&gt;해시 충돌은 해시함수를 거친 키값이 같은 값들. 즉, 다른 데이터의 키 값(해시값)들이 동일할 경우 해시 충돌이 발생한다.
이 충돌은 해시 테이블의 성능을 떨어뜨린다. 
해시 충돌을 방지하려면 해시 함수를 잘 정의하면 된다. 하지만 해시함수의 입력값은 무한하지만, 
출력값의 가짓수는 유한(출력값, 즉 키가 유한하지 않다면 해시기법을 사용하는 의미가 없다.)하므로 
해시 충돌은 반드시 발생한다.(비둘기집 원리)&lt;/p&gt;

&lt;p&gt;이러한 해시충돌을 방지할 방법은 크게 2가지가 있다.
&lt;b&gt;체이닝(Chaining)&lt;/b&gt;
버킷내에 LinkedList를 할당하여, Bucket에 데이터를 저장하다가 해시 충돌이 발생하면 연결리스트로 데이터를 연결하는 방식이다.&lt;/p&gt;

&lt;p&gt;&lt;b&gt;개방 주소법(Open Addressing)&lt;/b&gt;
해시 충돌이 발생하면 다른 Bucket에 데이터를 삽입하는 방식이다.
체이닝은 주소값은 동일한 상태로 LinkedList를 이용하여 늘려가기 때문에, 주소값이 변경되지는 않는다는 부분과 차이가 있다.
&lt;img src=&quot;./assets/built/images/algorithm/hash/hash_chaining1.PNG&quot; alt=&quot;ex_screenshot&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;b&gt;3가지 개방 주소법&lt;/b&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;b&gt;선형 탐색&lt;Linear Probing=&quot;&quot;&gt;&amp;lt;/b&amp;gt;: 해시 충돌 시 다음 버킷 혹은 몇개를 건너뛰어 데이터를 삽입&lt;/Linear&gt;&lt;/b&gt;&lt;/li&gt;
  &lt;li&gt;&lt;b&gt;제곱 탐색&lt;Quadratic Probing=&quot;&quot;&gt;&amp;lt;/b&amp;gt;: 해시 충돌 시 제곱만큼 건너뛴 버켓에 데이터를 삽입&lt;/Quadratic&gt;&lt;/b&gt;&lt;/li&gt;
  &lt;li&gt;&lt;b&gt;이중 해시&lt;Double Hashing=&quot;&quot;&gt;&amp;lt;/b&amp;gt;: 해시 충돌 시 다른 해시 함수를 한 번 더 적용한 결과를 이용&lt;/Double&gt;&lt;/b&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;./assets/built/images/algorithm/hash/hash_openaddressing.PNG&quot; alt=&quot;ex_screenshot&quot; /&gt;&lt;/p&gt;

&lt;h3&gt;해시를 이용한 자료구조&lt;/h3&gt;
&lt;p&gt;해시를 이용한 자료구조엔 &lt;b&gt;HashMap, HashTable&lt;/b&gt;이 있다.
둘의 차이는 &lt;b&gt;동기화 지원&lt;/b&gt;이 가능하냐 안하냐의 차이(synchronized)가 있다고 한다.&lt;/p&gt;

&lt;h3&gt;해시 자료구조의 시간 복잡도&lt;/h3&gt;
&lt;p&gt;해시함수로 만들어진 키값들은 고유한 인덱스를 가지게 되어 바로 접근할 수 있다.
그러므로 평균 O(1)의 시간복잡도를 가지고 있지만, 데이터 충돌이 발생할 경우 Chaining에 연결된 리스트들까지
검색해야 하므로 O(N)까지 시간복잡도가 증가할 수 있다.
충돌을 방지하는 방법들은 데이터의 규칙성(클러스터링)을 방지하기 위한 방식이지만 공간을 많이 사용한다는 치명적인 단점이 있다.&lt;/p&gt;

&lt;p&gt;만약 테이블이 꽉 차있는 경우라면 테이블을 확장해주어야 하는데, 이는 매우 심각한 성능의 저하를 불러오기 때문에 가급적이면 확장을 하지 않도록 테이블을 설계해주어야 한다.&lt;/p&gt;

&lt;p&gt;(통계적으로 해시 테이블의 공간 사용률이 70% ~ 80%정도가 되면 해시의 충돌이 빈번하게 발생하여 성능이 저하되기 시작한다고 한다.)&lt;/p&gt;

&lt;p&gt;또한 해시 테이블에서 자주 사용하게 되는 데이터를 Cache에 적용하면 효율을 높일 수 있다. 자주 hit하게 되는 데이터를 캐시에서 바로 찾음으로써 해시 테이블의 성능을 향상시킬 수 있다&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;./assets/built/images/algorithm/hash/hash_chaining_time.PNG&quot; alt=&quot;ex_screenshot&quot; /&gt;&lt;/p&gt;

&lt;p&gt;출처 
https://mangkyu.tistory.com/102 [MangKyu’s Diary]
https://preamtree.tistory.com/20 [Preamtree의 행복로그]&lt;/p&gt;</content><author><name>Ko</name></author><category term="algorithm" /><summary type="html">오늘은 Hash에 대하여 정리를 해보려고 한다.</summary></entry><entry><title type="html">Python 강좌(1) - Python 기본</title><link href="https://sanseongko.github.io/python-basic" rel="alternate" type="text/html" title="Python 강좌(1) - Python 기본" /><published>2021-05-17T00:00:00+09:00</published><updated>2021-05-17T00:00:00+09:00</updated><id>https://sanseongko.github.io/python-basic</id><content type="html" xml:base="https://sanseongko.github.io/python-basic">&lt;p&gt;&lt;span class=&quot;table-of-contents-list&quot;&gt;Python 강좌는 여러 절로 구성되어 있습니다. &lt;/span&gt;&lt;/p&gt;
&lt;ul class=&quot;table-of-contents-list&quot;&gt;
    &lt;li&gt;&lt;a href=&quot;./python-basic&quot;&gt;Python 강좌(1) - Python 기본&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;./python-control-statement&quot;&gt;Python 강좌(2) - Python 제어문&lt;/a&gt;&lt;/li&gt;
    &lt;!-- 날짜, 확장자 제외한 파일 이름을 쓰는 것 --&gt;
&lt;/ul&gt;
&lt;p&gt;이 글은 pyhon basic에 입니다.!!&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;syntaxHighlight&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;code&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
   &lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;foo&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;Hello World&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
   &lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;bar&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;100&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name>sanseongKo</name></author><category term="python" /><summary type="html">Python 강좌는 여러 절로 구성되어 있습니다. Python 강좌(1) - Python 기본 Python 강좌(2) - Python 제어문 이 글은 pyhon basic에 입니다.!!</summary></entry><entry><title type="html">Python 강좌(2) - Python 제어문</title><link href="https://sanseongko.github.io/python-control-statement" rel="alternate" type="text/html" title="Python 강좌(2) - Python 제어문" /><published>2021-05-17T00:00:00+09:00</published><updated>2021-05-17T00:00:00+09:00</updated><id>https://sanseongko.github.io/python-control-statement</id><content type="html" xml:base="https://sanseongko.github.io/python-control-statement">&lt;p&gt;&lt;span class=&quot;table-of-contents-list&quot;&gt;Python 강좌는 여러 절로 구성되어 있습니다. &lt;/span&gt;&lt;/p&gt;
&lt;ul class=&quot;table-of-contents-list&quot;&gt;
    &lt;li&gt;&lt;a href=&quot;./python-basic&quot;&gt;Python 강좌(1) - Python 기본&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;./python-control-statement&quot;&gt;Python 강좌(2) - Python 제어문&lt;/a&gt;&lt;/li&gt;
    &lt;!-- 날짜, 확장자 제외한 파일 이름을 쓰는 것 --&gt;
&lt;/ul&gt;
&lt;p&gt;이 글은 pyhon의 제어문에 대한 내용 입니다.!!&lt;/p&gt;
&lt;noscript&gt;&lt;pre&gt;# Jekyll configuration
markdown: kramdown
# kramdown : markdown의 개조판.
# markdown에서 불편한 사항을 개선한 형태.

# MyData 인적 사항
owner:
  name:           sanseongKo
  avatar:         photo.jpg
  bio:            &amp;quot;Ph.D. in Computer Science&amp;quot;
  email:          tkstjd56@naver.com
  # Social networking links used in footer. Update and remove as you like.
  twitter:
  facebook:
  github:
  stackexchange:
  linkedin:
  instagram:
  flickr:
  tumblr:
  # google plus id, include the &amp;#39;+&amp;#39;, eg +mmistakes
  google_plus:

highlighter: rouge
# text highlighter로 rouge이용
# 2016.02월 이후로 syntax highlighter는 rouge만 지원.
# Pygments 사용불가.

paginate: 20
# 작성한 모든 post를 하나의 페이지에 열거할 수 없으니
# pagination이 필요하고 몇개의 post를 하나의 page에서
# 보여줄 건지를 설정.

language: &amp;#39;en-uk&amp;#39;
# 언어 설정

url: https://sanseongKo.github.io
# Google Search Console에서 사용하는 sitemap.xml 생성시
# 이 url key값이 존재하지 않으면 sitemap.xml이
# 정상적으로 생성되지 않는다.
# 또한 disqus(댓글시스템)를 이용하기 위해서도 필요.
# 자신의 github page url을 입력
# ( https://your_github_id.github.io 형식 )

baseurl: /

# Website info
title: IT Technical Training
# 자신의 blog title.

description: IT기반기술교육 블로그
# blog home에 표시될 blog에 대한 전반적인 설명.

cover: assets/built/images/blog-cover1.jpg
# blog home에 표시될 blog cover image.

logo:
logo_dark:

favicon: assets/built/images/favicon.jpg
# favicon으로 사용할 image

production_url: https://sanseong.github.io
# 최종적으로 blog가 운영될 url

source_url: https://github.com/sanseongKo/GitHubPage
# blogmaker(jekyll source folder)에 대한 github repository

# Social info
navigation: True
# Navigation bar link를 보여줄건지 여부

subscribers: True
# subscriber 기능을 사용할건지의 여부
# 저는 약간의 수정을 통해 subscriber 기능대신
# lunr.js를 이용한 검색 기능으로 대체 사용했습니다.
# 검색기능으로 대체하기 위해서
# `_includes/subscribe-form.html` 파일의 수정이 필요합니다.

twitter:
facebook:
# 만약 twitter와 facebook을 이용하면 username을 입력

# Disqus
disqus: True
disqus_shortname: xxxxxxxx
# disqus는 온라인 댓글 시스템. 댓글 기능을 사용하기 위해
# disqus를 이용할 것인지 여부와 만약 사용하면
# disqus shortname을 입력 ( disqus username이 아님 )


# Google Analytics
google_analytics: UA-xxxxxxxx-x # replace with your GA tracking identifier
# Google Analytics을 사용할 경우 GA tracking identifier를 입력

# Permalinks
permalink: /:title
# permalink: /author/:author
# permalink: /tag/:title
# 각각의 post에 고정주소를 어떤 방식으로 할당할 것인지를 결정
# 이 값을 바꾸면 작성한 포스트의 저장위치나 파일이름이 변경된다.

# gems and other configs
plugins: [jekyll-paginate, jekyll-feed, jekyll-gist]

feed:
  path: feed.xml

# Travis-CI 설정입니다. 배포 빌드 자동화
safe: False
lsi: False

username: tkstjd56
repo: GitHubPageMaker
# username : travis-ci와 연동하는 github의 username
# repo: travis-ci와 연동하는 github의 repository이름
# https://github.com/&amp;lt;username&amp;gt;/&amp;lt;repository&amp;gt;

branch: master
# 사용할 branch명

relative_source:

destination: ../[GitHubPage]/
#./output/
# compile된 결과가 생성되는 폴더
# 이 폴더안의 내용이 우리가 운영하는 블로그 내용이 컴파일되서 들어간다.
# 이 폴더안의 내용을 github repository(https://username.github.io)에 push
# 만약 Travis-CI를 이용할 예정이면 이 부분을 git submodule로
# github repository(https://username.github.io)에 연결해야 한다.


# exclude는 Jekyll컴파일 시 destination에 포함될 필요가
# 없는것들을 명시한다. (node_modules와 필요없는 것들은 제외)
exclude:
  - README.md
  - Rakefile
  - Gemfile
  - Gemfile.lock
  - changelog.md
  - &amp;quot;*.Rmd&amp;quot;
  - vendor
  - .travis.yml
  - node_modules
  - assets/css
  - assets/images
  - _posts/angular
  - _posts/et-cetera
 # - _posts/python
  - _posts/typescript
  #  - _posts/jekyll
  - _posts/iot
  - _posts/r
  - _posts/economy&lt;/pre&gt;&lt;/noscript&gt;
&lt;script src=&quot;https://gist.github.com/sanseongKo/dfa10e997612310abe016e8411516e8b.js&quot;&gt; &lt;/script&gt;</content><author><name>sanseongKo</name></author><category term="python" /><summary type="html">Python 강좌는 여러 절로 구성되어 있습니다. Python 강좌(1) - Python 기본 Python 강좌(2) - Python 제어문 이 글은 pyhon의 제어문에 대한 내용 입니다.!! # Jekyll configuration markdown: kramdown # kramdown : markdown의 개조판. # markdown에서 불편한 사항을 개선한 형태. # MyData 인적 사항 owner: name: sanseongKo avatar: photo.jpg bio: &amp;quot;Ph.D. in Computer Science&amp;quot; email: tkstjd56@naver.com # Social networking links used in footer. Update and remove as you like. twitter: facebook: github: stackexchange: linkedin: instagram: flickr: tumblr: # google plus id, include the &amp;#39;+&amp;#39;, eg +mmistakes google_plus: highlighter: rouge # text highlighter로 rouge이용 # 2016.02월 이후로 syntax highlighter는 rouge만 지원. # Pygments 사용불가. paginate: 20 # 작성한 모든 post를 하나의 페이지에 열거할 수 없으니 # pagination이 필요하고 몇개의 post를 하나의 page에서 # 보여줄 건지를 설정. language: &amp;#39;en-uk&amp;#39; # 언어 설정 url: https://sanseongKo.github.io # Google Search Console에서 사용하는 sitemap.xml 생성시 # 이 url key값이 존재하지 않으면 sitemap.xml이 # 정상적으로 생성되지 않는다. # 또한 disqus(댓글시스템)를 이용하기 위해서도 필요. # 자신의 github page url을 입력 # ( https://your_github_id.github.io 형식 ) baseurl: / # Website info title: IT Technical Training # 자신의 blog title. description: IT기반기술교육 블로그 # blog home에 표시될 blog에 대한 전반적인 설명. cover: assets/built/images/blog-cover1.jpg # blog home에 표시될 blog cover image. logo: logo_dark: favicon: assets/built/images/favicon.jpg # favicon으로 사용할 image production_url: https://sanseong.github.io # 최종적으로 blog가 운영될 url source_url: https://github.com/sanseongKo/GitHubPage # blogmaker(jekyll source folder)에 대한 github repository # Social info navigation: True # Navigation bar link를 보여줄건지 여부 subscribers: True # subscriber 기능을 사용할건지의 여부 # 저는 약간의 수정을 통해 subscriber 기능대신 # lunr.js를 이용한 검색 기능으로 대체 사용했습니다. # 검색기능으로 대체하기 위해서 # `_includes/subscribe-form.html` 파일의 수정이 필요합니다. twitter: facebook: # 만약 twitter와 facebook을 이용하면 username을 입력 # Disqus disqus: True disqus_shortname: xxxxxxxx # disqus는 온라인 댓글 시스템. 댓글 기능을 사용하기 위해 # disqus를 이용할 것인지 여부와 만약 사용하면 # disqus shortname을 입력 ( disqus username이 아님 ) # Google Analytics google_analytics: UA-xxxxxxxx-x # replace with your GA tracking identifier # Google Analytics을 사용할 경우 GA tracking identifier를 입력 # Permalinks permalink: /:title # permalink: /author/:author # permalink: /tag/:title # 각각의 post에 고정주소를 어떤 방식으로 할당할 것인지를 결정 # 이 값을 바꾸면 작성한 포스트의 저장위치나 파일이름이 변경된다. # gems and other configs plugins: [jekyll-paginate, jekyll-feed, jekyll-gist] feed: path: feed.xml # Travis-CI 설정입니다. 배포 빌드 자동화 safe: False lsi: False username: tkstjd56 repo: GitHubPageMaker # username : travis-ci와 연동하는 github의 username # repo: travis-ci와 연동하는 github의 repository이름 # https://github.com/&amp;lt;username&amp;gt;/&amp;lt;repository&amp;gt; branch: master # 사용할 branch명 relative_source: destination: ../[GitHubPage]/ #./output/ # compile된 결과가 생성되는 폴더 # 이 폴더안의 내용이 우리가 운영하는 블로그 내용이 컴파일되서 들어간다. # 이 폴더안의 내용을 github repository(https://username.github.io)에 push # 만약 Travis-CI를 이용할 예정이면 이 부분을 git submodule로 # github repository(https://username.github.io)에 연결해야 한다. # exclude는 Jekyll컴파일 시 destination에 포함될 필요가 # 없는것들을 명시한다. (node_modules와 필요없는 것들은 제외) exclude: - README.md - Rakefile - Gemfile - Gemfile.lock - changelog.md - &amp;quot;*.Rmd&amp;quot; - vendor - .travis.yml - node_modules - assets/css - assets/images - _posts/angular - _posts/et-cetera # - _posts/python - _posts/typescript # - _posts/jekyll - _posts/iot - _posts/r - _posts/economy</summary></entry></feed>