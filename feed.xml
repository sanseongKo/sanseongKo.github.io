<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.9.0">Jekyll</generator><link href="https://sanseongko.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="https://sanseongko.github.io/" rel="alternate" type="text/html" /><updated>2021-06-27T22:03:27+09:00</updated><id>https://sanseongko.github.io/feed.xml</id><title type="html">SanseongKo’s Blog</title><subtitle>온리 공부를 위한 블로그</subtitle><entry><title type="html">프로그래머스 코딩테스트 연습 주식가격(스택/큐) 문제</title><link href="https://sanseongko.github.io/codingtest-stockprice" rel="alternate" type="text/html" title="프로그래머스 코딩테스트 연습 주식가격(스택/큐) 문제" /><published>2021-06-27T00:00:00+09:00</published><updated>2021-06-27T00:00:00+09:00</updated><id>https://sanseongko.github.io/codingtest-stockprice</id><content type="html" xml:base="https://sanseongko.github.io/codingtest-stockprice">&lt;p&gt;다리를 지나가는 트럭 이후에 프로그래머스 스택/큐의 마지막 문제 주식가격의 문제를 풀었다. 한번에 통과되었고, 스택/큐 문제였지만, 안쓰는게 더 나아보여서
그냥 배열로 풀었다.
&lt;script src=&quot;https://gist.github.com/sanseongKo/53d9712294d940d6cd76e9e470cbae2b.js&quot;&gt;&lt;/script&gt;
성공한 코드이고, 효율성도 만족하였다.
그나마 쉬운 문제였다고 생각이 들고 마지막 0을 맞추는 것과, 중간에 time이 0으로 초기화되었는데 수정하였다.&lt;/p&gt;</content><author><name>Ko</name></author><category term="codingtest" /><summary type="html">다리를 지나가는 트럭 이후에 프로그래머스 스택/큐의 마지막 문제 주식가격의 문제를 풀었다. 한번에 통과되었고, 스택/큐 문제였지만, 안쓰는게 더 나아보여서 그냥 배열로 풀었다. 성공한 코드이고, 효율성도 만족하였다. 그나마 쉬운 문제였다고 생각이 들고 마지막 0을 맞추는 것과, 중간에 time이 0으로 초기화되었는데 수정하였다.</summary></entry><entry><title type="html">프로그래머스 코딩테스트 연습 다리를 지나는 트럭(스택/큐) 문제</title><link href="https://sanseongko.github.io/codingtest-truck" rel="alternate" type="text/html" title="프로그래머스 코딩테스트 연습 다리를 지나는 트럭(스택/큐) 문제" /><published>2021-06-27T00:00:00+09:00</published><updated>2021-06-27T00:00:00+09:00</updated><id>https://sanseongko.github.io/codingtest-truck</id><content type="html" xml:base="https://sanseongko.github.io/codingtest-truck">&lt;p&gt;오늘은 프로그래머스 코딩테스트 연습의 다리를 지나는 트럭 문제를 풀어보았다. 
처음에 나는 길이와 트럭의 길이가 문제에 주어져 있지 않아서 트럭의 무게 = 트럭의 길이인줄 알았다. 
그래서 헤메다가 다시 문제를 읽어보니 트럭길이가 1이지 않을까 하는 생각이 들어서 대입하여 풀어보았고, 이게 맞긴했다.
처음 내가 풀었던 코드이다.(실패한 코드)
&lt;script src=&quot;https://gist.github.com/sanseongKo/85a7aeee22a684544a75e14eefd45774.js&quot;&gt;&lt;/script&gt;
실패한 이유는 다리에 올라가 있는 트럭의 무게가 다리가 견딜수 있는 하중보다 작으면 된다라는 점은 동일했다. 하지만, 문제가 되는 부분은 만약 2대의 트럭이 
다리에 올라가 있다고 하고, 다리가 견딜수 있는 하중보다 2대가 같거나 적었을 경우인데, 이중에 한대가 빠져나갔다고하고 다음 들어오는 트럭과 남아있는 한대의
트럭이 합이 하중보다 작을 경우 한대는 끝에 다다르고 한대는 시작점에 있는데 이부분에서 걸리는 시간이 차이가 나는 것이다.&lt;br /&gt;
이 부분을 어떻게 맞춰줘야 할까하여, 결국 구글에 해당 답을 찾아보게 되었고, 문제는 간단했다. 큐에 트럭을 담는 것과 무게를 비교해주는 것은 동일했다.
하지만 큐에 트럭만 담아주는 것이 아닌, 다른 수를 넣어(보통 0을 넣으셨다) que.size()를 다리 길이와 맞춰주고 쉽게 한칸씩 앞으로 간다면, 초를 증가시켜
주면 되는 것이었다.&lt;br /&gt;
밑에는 아이디어를 받고 다시 작성한 정답 코드이다.
&lt;script src=&quot;https://gist.github.com/sanseongKo/8246337b3918b309a79de837a4b12482.js&quot;&gt;&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;큐를 길이로도 쓸 수 있다!(담고 빼는거만 생각하지말자)&lt;/p&gt;</content><author><name>Ko</name></author><category term="codingtest" /><summary type="html">오늘은 프로그래머스 코딩테스트 연습의 다리를 지나는 트럭 문제를 풀어보았다. 처음에 나는 길이와 트럭의 길이가 문제에 주어져 있지 않아서 트럭의 무게 = 트럭의 길이인줄 알았다. 그래서 헤메다가 다시 문제를 읽어보니 트럭길이가 1이지 않을까 하는 생각이 들어서 대입하여 풀어보았고, 이게 맞긴했다. 처음 내가 풀었던 코드이다.(실패한 코드) 실패한 이유는 다리에 올라가 있는 트럭의 무게가 다리가 견딜수 있는 하중보다 작으면 된다라는 점은 동일했다. 하지만, 문제가 되는 부분은 만약 2대의 트럭이 다리에 올라가 있다고 하고, 다리가 견딜수 있는 하중보다 2대가 같거나 적었을 경우인데, 이중에 한대가 빠져나갔다고하고 다음 들어오는 트럭과 남아있는 한대의 트럭이 합이 하중보다 작을 경우 한대는 끝에 다다르고 한대는 시작점에 있는데 이부분에서 걸리는 시간이 차이가 나는 것이다. 이 부분을 어떻게 맞춰줘야 할까하여, 결국 구글에 해당 답을 찾아보게 되었고, 문제는 간단했다. 큐에 트럭을 담는 것과 무게를 비교해주는 것은 동일했다. 하지만 큐에 트럭만 담아주는 것이 아닌, 다른 수를 넣어(보통 0을 넣으셨다) que.size()를 다리 길이와 맞춰주고 쉽게 한칸씩 앞으로 간다면, 초를 증가시켜 주면 되는 것이었다. 밑에는 아이디어를 받고 다시 작성한 정답 코드이다.</summary></entry><entry><title type="html">프로그래머스 코딩테스트 연습 위장(해시) 문제</title><link href="https://sanseongko.github.io/codingtest-spy" rel="alternate" type="text/html" title="프로그래머스 코딩테스트 연습 위장(해시) 문제" /><published>2021-06-15T00:00:00+09:00</published><updated>2021-06-15T00:00:00+09:00</updated><id>https://sanseongko.github.io/codingtest-spy</id><content type="html" xml:base="https://sanseongko.github.io/codingtest-spy">&lt;p&gt;코딩테스트 연습으로 해시의 위장 문제를 풀어보았다.
우선 내가 작성한 코드이고, 물론 실패했다. 친구랑 시간내에 풀기로하여 시간을 맞추지 못했다…
&lt;br /&gt;
&lt;script src=&quot;https://gist.github.com/sanseongKo/6a98704ee60515c628d4588c470eab79.js&quot;&gt;&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;모든 조합을 구하려고 했는데,&lt;/p&gt;
&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nx&quot;&gt;sb&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;delete&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;sb&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;());&lt;/span&gt;
        	&lt;span class=&quot;nx&quot;&gt;set2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;clear&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;이 부분에서 초기화를 하며 전에 있던 옷까지 사라져 같은 조합이나와도 그 수를 인식해버리는 것 같다. &lt;br /&gt;
친구가 푼 코드는 해시 맵을 이용하여 모든 옷의 타입의 수를 구하여 경우의 수 구하는 법으로 구했다고 한다. 그런데 그런의도일까..?&lt;/p&gt;

&lt;p&gt;프로그래머스 제일 처음 나오는 분의 코드는 
&lt;br /&gt;&lt;/p&gt;
&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;java&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;util&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;java&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;util&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;stream&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;Collectors&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Solution&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kr&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;solution&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[][]&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;clothes&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Arrays&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;stream&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;clothes&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
                &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;collect&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;groupingBy&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;mapping&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;counting&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())))&lt;/span&gt;
                &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;values&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
                &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;stream&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
               &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;collect&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;reducing&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;L&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))).&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;intValue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
   &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;이렇게 생겼다. 모르는게 천지;; 람다식으로 간단하게 표현이 가능한 것 같다. 람다식을 공부해야겠네…&lt;/p&gt;</content><author><name>Ko</name></author><category term="codingtest" /><summary type="html">코딩테스트 연습으로 해시의 위장 문제를 풀어보았다. 우선 내가 작성한 코드이고, 물론 실패했다. 친구랑 시간내에 풀기로하여 시간을 맞추지 못했다…</summary></entry><entry><title type="html">프로그래머스 코딩테스트 연습 기능개발(스택/큐) 문제</title><link href="https://sanseongko.github.io/codingtest-functiondevelop" rel="alternate" type="text/html" title="프로그래머스 코딩테스트 연습 기능개발(스택/큐) 문제" /><published>2021-06-15T00:00:00+09:00</published><updated>2021-06-15T00:00:00+09:00</updated><id>https://sanseongko.github.io/codingtest-functiondevelop</id><content type="html" xml:base="https://sanseongko.github.io/codingtest-functiondevelop">&lt;p&gt;코딩테스트 연습으로 해시의 위장 문제를 풀어보았다.
우선 내가 작성한 코드이고, 성공했지만, 시간내에 풀지는 못했다…
&lt;br /&gt;
&lt;script src=&quot;https://gist.github.com/sanseongKo/d6a8351afa53f6b8e414f16997087aa8.js&quot;&gt;&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;데이는 걸리는 시간으로 처음 순서대로 큐를 이용하여 큐에 값을 넣고 그 값들을 나오는대로 비교해 나갔다. 마지막&lt;/p&gt;
&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nx&quot;&gt;tmp&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;que&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;poll&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;que&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;peek&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        	&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;tmp&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;=&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;que&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;peek&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        		&lt;span class=&quot;nx&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        		&lt;span class=&quot;nx&quot;&gt;que&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;poll&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
        	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        		&lt;span class=&quot;nx&quot;&gt;arr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        		&lt;span class=&quot;nx&quot;&gt;count&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        		&lt;span class=&quot;nx&quot;&gt;tmp&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;que&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;poll&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
        	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        	&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;que&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;peek&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        		&lt;span class=&quot;nx&quot;&gt;arr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;이 부분에서 뇌절이 와버려서, 시간이 걸렸고 tmp &amp;gt;= que.peek() 부분에서 &amp;gt;=가 아닌 &amp;gt;로 해버려서 또 시간을 버렸다.
&lt;br /&gt;&lt;br /&gt;
밑에는 다른 사람의 풀이의 처음에 있는 분의 풀이이다.&lt;/p&gt;
&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;java&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;util&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;ArrayList&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;java&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;util&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;Arrays&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Solution&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kr&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;solution&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;progresses&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;speeds&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;nx&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;dayOfend&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;100&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
        &lt;span class=&quot;nx&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;day&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;progresses&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;progresses&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;day&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;speeds&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;100&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;nx&quot;&gt;day&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
            &lt;span class=&quot;nx&quot;&gt;dayOfend&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;day&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Arrays&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;stream&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;dayOfend&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;filter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;toArray&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;하, 람다식 진짜… ㅋㅋㅋ 오늘부터라도 공부한다 내가. 그리고 Arrays.stream 이 부분이 자주보이는데 여기도 확인을 해봐야 할 것 같다.&lt;/p&gt;</content><author><name>Ko</name></author><category term="codingtest" /><summary type="html">코딩테스트 연습으로 해시의 위장 문제를 풀어보았다. 우선 내가 작성한 코드이고, 성공했지만, 시간내에 풀지는 못했다…</summary></entry><entry><title type="html">inflearn강의 Sort and Searching복습</title><link href="https://sanseongko.github.io/codingtest-sortcodingclass" rel="alternate" type="text/html" title="inflearn강의 Sort and Searching복습" /><published>2021-06-15T00:00:00+09:00</published><updated>2021-06-15T00:00:00+09:00</updated><id>https://sanseongko.github.io/codingtest-sortcodingclass</id><content type="html" xml:base="https://sanseongko.github.io/codingtest-sortcodingclass">&lt;p&gt;정렬 알고리즘 강의 들은 것에 관하여 정리를 해보려 한다.(요기요 코딩테스트도 오늘 보았다)
첫번째 문제에서는 조건에 맞는 배열의 데이터를 빼내어 다른 배열에 담고, 인덱스를 기억하여 정렬을 하는 것이 핵심이었다.
인덱스를 증가 시켜놓은 상태로, 또는 인덱스를 최대에서 줄이면서, 인덱스를 기억시켜놓고 인덱스에 맞게 정렬을 하는 방식이다.
언제나 문제의 조건을 정리하여 그대로 코딩화하는 것이 중요한 것 같다.&lt;/p&gt;

&lt;p&gt;두번째 문제는 힙을 이용하여 정렬을 하는 방법이고, 큰 수부터 정렬하여 그 중 몇 번째 숫자를 리턴하는 것이다.
Priority Queue&lt;/p&gt;</content><author><name>Ko</name></author><category term="codingtest" /><summary type="html">정렬 알고리즘 강의 들은 것에 관하여 정리를 해보려 한다.(요기요 코딩테스트도 오늘 보았다) 첫번째 문제에서는 조건에 맞는 배열의 데이터를 빼내어 다른 배열에 담고, 인덱스를 기억하여 정렬을 하는 것이 핵심이었다. 인덱스를 증가 시켜놓은 상태로, 또는 인덱스를 최대에서 줄이면서, 인덱스를 기억시켜놓고 인덱스에 맞게 정렬을 하는 방식이다. 언제나 문제의 조건을 정리하여 그대로 코딩화하는 것이 중요한 것 같다.</summary></entry><entry><title type="html">inflearn강의 복습</title><link href="https://sanseongko.github.io/codingtest-codingclass" rel="alternate" type="text/html" title="inflearn강의 복습" /><published>2021-06-15T00:00:00+09:00</published><updated>2021-06-15T00:00:00+09:00</updated><id>https://sanseongko.github.io/codingtest-codingclass</id><content type="html" xml:base="https://sanseongko.github.io/codingtest-codingclass">&lt;p&gt;뭔가 계속 불안해서 결국 인프런의 강의를 질렀다. 강의에서 나오는 내용들 위주로 공부를 진행하려고 한다.&lt;/p&gt;

&lt;h3&gt;String&lt;/h3&gt;
&lt;p&gt;&lt;b&gt;사전지식&lt;/b&gt;
&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;charAt(i) =&amp;gt; 문자열 위치(String “abcd”가 있으면 a는 charAt(1))&lt;/li&gt;
  &lt;li&gt;toCharArray =&amp;gt; char[]배열로 바꿔줌(위의 abcd를 배열로 바꿔줌)&lt;/li&gt;
  &lt;li&gt;IndexOf(), substring(begin, end) (특정 문자를 찾고 싶을 때, end인덱스는 마지막에서 끊는다)&lt;/li&gt;
  &lt;li&gt;startsWith(), endWith(), split() (ex. str.startWith(“a”)); =&amp;gt; true, split() =&amp;gt; 문자열을 특정 조건으로 스트링 배열로 바꿔줄 수 있음)&lt;/li&gt;
  &lt;li&gt;toLowerCase() =&amp;gt; 소문자로 바꿔줌&lt;/li&gt;
  &lt;li&gt;replace() =&amp;gt; 특정한 문자가 나오면 그거를 뭐로 바꿔줘라&lt;/li&gt;
  &lt;li&gt;Character,isDigit(c), Character.isLetter (전자 =&amp;gt; 0,1이런 숫자냐, 후자 =&amp;gt; 문자이냐) –&amp;gt; true&lt;/li&gt;
  &lt;li&gt;StringBuilder sb = new StringBuilder(); ex) sb.append(“aa”)&lt;/li&gt;
&lt;/ol&gt;

&lt;h3&gt;String 문제 1&lt;h3&gt;
1. Basic한 방법으로, 이메일이 담기는 배열을 파라미터로 받을 경우, for문을 돌려 각 이메일마다 charAt으로 나눠주고 조건을 확인시키는 방법이다. 
여기서 주의할 점은 substring(숫자) 이 숫자 부분이 배열의 번호부터 출력이 된다.
   
2. split을 가지고 하는 방법으로, 각 조건마다 split으로 String 배열로 만들어주고 그 배열을 replace(&quot;.&quot;, &quot;&quot;)로 바꿔주면 된다. 굉장히 간단했다.

&lt;br /&gt;&lt;br /&gt;

&lt;b&gt;1번 문제의 시간복잡도/공간복잡도 계산&lt;/b&gt;
&lt;br /&gt;&lt;br /&gt;
1. 시간 복잡도 : 대상 =&amp;gt; 문제에서 입력받은 파라미터 (속도)
2. 공간 복잡도 : 대상 =&amp;gt; 실제 사용되는 저장 공간을 계산
&lt;br /&gt;&lt;br /&gt;
&lt;b&gt;참고&lt;/b&gt;
   &lt;br /&gt;&lt;br /&gt;
1. O(1): 스택, 큐, Map
2. O(N): for문 =&amp;gt; 데이터를 한번씩 호출하기 때문
3. O(logN): sort, priorityQueue, binary Search Tree, Tree
4. O(KlogN): k번만큼 소팅하는 경우
5. O(N^2): 이중 for문
6. O(m*n): 이중 for문이지만, n이 다른 경우 bfs, dfs류 

&lt;br /&gt;&lt;br /&gt;
&lt;h3&gt;2. 보석 찾기 문제&lt;/h3&gt;

&lt;b&gt;Set&lt;/b&gt;은 대소문자를 구별한다. Set.contain(something) something이 Set에 들어있는지 확인 시켜줄 수 있다.(count를 할 때 유용할 듯)

&lt;h3&gt;3. 문자 파싱 문제&lt;/h3&gt;
&lt;b&gt;StringBuilder&lt;/b&gt;의 insert 메소드를 사용, (insert(8, &quot;!&quot;))이렇게 되어 있으면, 배열처럼 0번부터 시작해서 8번째에 해당 문자를 삽입한다.
삽입하고 딱 그자리에 들어가고 나머지는 밀리는 느낌이기 때문에, 잘 계산해서 사용하여야 겠다.

&lt;br /&gt;&lt;br /&gt;
제일 중요한건, 사실 생각인 것 같다. 코딩테스트 문제를 풀어봐도 항상 나는 구현쪽에서 막힌다.(그만큼 아는게 적다는 뜻이겠지)&lt;br /&gt;
어지간하면 문제 이해는 어렵지 않다. 어떤 것을 사용할지도 머리에 떠오르지만 중간 중간 문제되는 부분들에 막히면서 코드가 복잡해진다.&lt;br /&gt;
아는 선에서 생각하고 바로 떠오르긴 하지만 그것이 제대로 된 접근이 아니기 때문에 문제 해결을 위하여 코드가 추가되다보니 복잡해지고 시간을 잡아 먹는 것 같다.
초반 스트링의 관한 문제들이기 때문에, 그렇게 어렵게 다가오지 않았다. 원래 목표는 dfs,bfs의 이해이기 때문에(찾아보니, 속도가 굉장히 느린데 왜 쓰는건지 궁금;;) 달려보자.




&lt;/h3&gt;&lt;/h3&gt;</content><author><name>Ko</name></author><category term="codingtest" /><summary type="html">뭔가 계속 불안해서 결국 인프런의 강의를 질렀다. 강의에서 나오는 내용들 위주로 공부를 진행하려고 한다.</summary></entry><entry><title type="html">카카오 2021 블라인드 코딩테스트 1번</title><link href="https://sanseongko.github.io/codingtest-2021_kakao01" rel="alternate" type="text/html" title="카카오 2021 블라인드 코딩테스트 1번" /><published>2021-06-15T00:00:00+09:00</published><updated>2021-06-15T00:00:00+09:00</updated><id>https://sanseongko.github.io/codingtest-2021_kakao01</id><content type="html" xml:base="https://sanseongko.github.io/codingtest-2021_kakao01">&lt;h3&gt;문제&lt;/h3&gt;
&lt;p&gt;카카오에 입사한 신입 개발자 네오는 “카카오계정개발팀”에 배치되어, 카카오 서비스에 가입하는 유저들의 아이디를 생성하는 업무를 담당하게 되었습니다.
“네오”에게 주어진 첫 업무는 새로 가입하는 유저들이 카카오 아이디 규칙에 맞지 않는 아이디를 입력했을 때, 입력된 아이디와 유사하면서 규칙에 맞는 
아이디를 추천해 주는 프로그램을 개발하는 것입니다.
&lt;br /&gt;
&lt;a href=&quot;https://tech.kakao.com/2021/01/25/2021-kakao-recruitment-round-1/&quot;&gt;문제 자세히 보기&lt;/a&gt;&lt;/p&gt;

&lt;h3&gt;풀이&lt;/h3&gt;
&lt;p&gt;7가지의 조건들을 순서대로 적용하여 문제를 풀었다.
&lt;br /&gt;
&lt;script src=&quot;https://gist.github.com/sanseongKo/dab3325f2e1466eb26eca73783ed6b46.js&quot;&gt;&lt;/script&gt;
&lt;br /&gt;
순서대로 적용시키면 되기 때문에, 어렵진 않았지만 코드가 좀 더러운 느낌…?(멀었다… 멀었어…)&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/sanseongKo/codingtest&quot;&gt;깃허브에서 보기&lt;/a&gt;&lt;/p&gt;

&lt;h3&gt;새로 알게된 메소드&lt;/h3&gt;
&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nb&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;id&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;new_id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;toLowerCase&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;오 소문자로 바로 바꿔주더이다, 처음 생각한건 아스키 코드였는데 있다면 안 쓸 이유가 없지. 물론, new_id.toUpperCase();를 하면 대문자로 변환 해
준다.(대문자, 소문자만 확인하여 변환하고 숫자나 기타 특수문자는 건들지 않아서 문제에 유용했다.)
&lt;br /&gt;&lt;/p&gt;
&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nx&quot;&gt;char&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;answer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;toCharArray&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;솔직히 몰랐다… 반복으로 char 배열에 넣어줘야 하는 줄 알았다…&lt;/p&gt;

&lt;p&gt;다 풀고나서, 다른 분의 풀이를 보았다… 잘한다… 
&lt;br /&gt;
정규 표현식&lt;/p&gt;</content><author><name>Ko</name></author><category term="codingtest" /><summary type="html">문제 카카오에 입사한 신입 개발자 네오는 “카카오계정개발팀”에 배치되어, 카카오 서비스에 가입하는 유저들의 아이디를 생성하는 업무를 담당하게 되었습니다. “네오”에게 주어진 첫 업무는 새로 가입하는 유저들이 카카오 아이디 규칙에 맞지 않는 아이디를 입력했을 때, 입력된 아이디와 유사하면서 규칙에 맞는 아이디를 추천해 주는 프로그램을 개발하는 것입니다. 문제 자세히 보기</summary></entry><entry><title type="html">기술 면접 예상 질문</title><link href="https://sanseongko.github.io/interview" rel="alternate" type="text/html" title="기술 면접 예상 질문" /><published>2021-06-13T00:00:00+09:00</published><updated>2021-06-13T00:00:00+09:00</updated><id>https://sanseongko.github.io/interview</id><content type="html" xml:base="https://sanseongko.github.io/interview">&lt;p&gt;기술 면접에 관하여, 내가 지원하려고 하는 자바, 스프링, 관련 지식 또는 CS관련 지식들을 적고 대답을 적어보는 포스팅을 하려고 한다.
면접에 가서 모른다는 답변을 너무 많이했다… 아는 건데 막상 설명을 하려니 못하겠어서 찾아보고 정리하고 정확하게 말을 할 수 있을 정도가 되었으면 한다.&lt;/p&gt;

&lt;h3&gt;자바&lt;/h3&gt;
&lt;p&gt;면접 질문 중에 쓰레드에 관한 질문이 나왔고, 쓰레드를 알고 있었지 자바에서 구현 가능한지는 몰랐다. 하지만 찾아보니 써봤던 거다.&lt;/p&gt;

&lt;h3&gt;자바에서 쓰레드&lt;/h3&gt;
&lt;p&gt;내가 찾아본 자바에서 쓰레드는 보통 코드가 한번에 하나씩 실행이 된다고 한다. 그렇지만, 여기에 쓰레드를 상속받아 사용한다면, start() 메소드를 사용할 
수 있고, start()가 실행될 때 run()를 수행하게 되어 있다.&lt;/p&gt;

&lt;h3&gt;사용 이유&lt;/h3&gt;
&lt;p&gt;보통은 동시에 많은 양의 요청이 들어오는 서비스에서, 그 요청들을 하나씩 처리한다면, 많은 시간이 소요가 될 것이다. 그렇게 많은 시간이 소요되는 부분을
동시에 처리하여 시간을 줄이기 위하여 사용이 된다. 하지만 쓰레드가 많아질 경우 컴퓨터의 부하가 심해지고, [교착상태]가 날 수 있기 때문에 주의하여 
사용을 해야한다.&lt;/p&gt;

&lt;h3&gt;사용 예&lt;/h3&gt;
&lt;script src=&quot;https://gist.github.com/sanseongKo/bda05eab70c50f964b821697d6eafcf4.js&quot;&gt;&lt;/script&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;./assets/built/images/interview/thread/threadcode.PNG&quot; alt=&quot;ex_screenshot&quot; /&gt;
위의 결과 처럼 원래대로라면, 생성자를 생성하고 run()이 순차적으로 실행되어야 하는데, 유저가 랜덤하게 메세지를 보내고 있는 것을 확인할 수 있다.&lt;/p&gt;</content><author><name>Ko</name></author><category term="interview" /><summary type="html">기술 면접에 관하여, 내가 지원하려고 하는 자바, 스프링, 관련 지식 또는 CS관련 지식들을 적고 대답을 적어보는 포스팅을 하려고 한다. 면접에 가서 모른다는 답변을 너무 많이했다… 아는 건데 막상 설명을 하려니 못하겠어서 찾아보고 정리하고 정확하게 말을 할 수 있을 정도가 되었으면 한다.</summary></entry><entry><title type="html">Spring Security 연습</title><link href="https://sanseongko.github.io/springsecurity" rel="alternate" type="text/html" title="Spring Security 연습" /><published>2021-06-13T00:00:00+09:00</published><updated>2021-06-13T00:00:00+09:00</updated><id>https://sanseongko.github.io/springsecurity</id><content type="html" xml:base="https://sanseongko.github.io/springsecurity">&lt;p&gt;기술 면접중 스프링 시큐리티에 관하여 질문을 받았고, 대답을 못했다. 돌아가는 모습은 내가 아는 모습은 비슷하지만, 지원을 해주는 것에서 많이 차이가
나는 것 같다. 편한기능이 많고, 알아두면 좋을 것 같다. 물론 어떻게 돌아가는지도 넣을 것이고, 자료는 유튜브 &lt;a href=&quot;https://www.youtube.com/watch?v=riwrVN1JVbU&quot;&gt;데어 프로그래밍&lt;/a&gt;님의
유튜브에서 가져왔고 설명이 잘되어 있는 것 같으니, 궁금할 땐 클릭해서 들어가 보자.(유튜브로 강의를 정말 잘해 놓으셨다.)&lt;/p&gt;

&lt;h3&gt;Spring Security 연습 1(2021-06-17)&lt;/h3&gt;

&lt;p&gt;&lt;br /&gt;
처음 시작에서 Spring Security 의존주입을 하고 나서, yml파일을 생성하고 내용을 정리해준다. 브라우저에 접속하여 url을 적으면, 자동으로 스프링
시큐리티가 login페이지로 넘겨준다. 아이디는 기본 user이며, 비밀번호는 처음 서버를 실행하고 나서 콘솔에 사진처럼 나타나게된다. spring security 
의존주입시 처음 들어가는 모든 요청 페이지는 막혀서 로그인을 해줘야하고 로그인이 되어야 접근이 가능하다는 점 유의하자. 또한 로그아웃도 지원하기 때문에, 
다시 서버를 실행하였다면, 로그아웃 한번 해주고 실행하자.(비밀번호도 재실행 될 때마다 변경됨)
&lt;img src=&quot;./assets/built/images/spring/securitypassword.PNG&quot; alt=&quot;ex_screenshot&quot; /&gt;
&lt;b&gt;MustacheViewResolver&lt;/b&gt;
해당 유튜브 강의에서는 html을 이용하여 초반에 뷰를 작성하였다. 하지만 처음 의존 주입을 Mustache로 하였기 때문에, 해당 configuration 클래스를
생성하고, MustacheViewResolver자료형으로 참조변수를 만들어 사용할 수 있다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-angular2html&quot;&gt;MustacheViewResolver resolver = new MustacheViewResolver();
		resolver.setCharset(&quot;UTF-8&quot;);
		resolver.setContentType(&quot;text/html; charset=UTF-8&quot;);
		resolver.setPrefix(&quot;classpath:/templates/&quot;);
		resolver.setSuffix(&quot;.html&quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이런식으로 만들어졌을 경우 .mustache로 설정되어 있던 suffix가 html로 경로 설정이 될 수 있도록 해준다.&lt;/p&gt;

&lt;h3&gt;Spring Security 연습 2(2021-06-18)&lt;/h3&gt;
&lt;p&gt;&lt;b&gt;@EnableWebSecurity&lt;/b&gt;
웹 보안을 활성화하고, WebSecurityConfigurer을 상속받아 클래스를 설정할 때 자주 쓰인다. @Configuration 클래스에 @EnableWebSecurity을 추가하여
스프링 시큐리티를 설정할 클래스라고 정의한다.
&lt;br /&gt;
&lt;br /&gt;
&lt;b&gt;WebSecurityConfigurer&lt;/b&gt;는 WebSecurityConfigurer 인스턴스를 편리하게 만들기 위하여 사용한다. 상속을 받게 되면, configure 메소드를 오버
라이딩 할 수 있고, 파라미터는 HttpSecurity 객체를 받게 된다.
&lt;br /&gt;
&lt;br /&gt;
&lt;b&gt;authorizeRequests()&lt;/b&gt;메서드는 시큐리티 처리에 HttpServletRequest를 이용한다는 것을 의미하고,
&lt;br /&gt;
&lt;br /&gt;
&lt;b&gt;antMatchers()&lt;/b&gt;는 특정 경로를 지정해줄 수 있는 메소드이다.
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;h4&gt;특정 경로 지정 후 사용 할 수 있는 인증 메서드&lt;/h4&gt;
&lt;p&gt;anonymous(): 인증되지 않은 사용자가 접근할 수 있습니다.
authenticated(): 인증된 사용자만 접근할 수 있습니다.
fullyAuthenticated(): 완전히 인증된 사용자만 접근할 수 있습니다(?)
hasRole() or hasAnyRole(): 특정 권한을 가지는 사용자만 접근할 수 있습니다.
hasAuthority() or hasAnyAuthority():특정 권한을 가지는 사용자만 접근할 수 있습니다.
hasIpAddress(): 특정 아이피 주소를 가지는 사용자만 접근할 수 있습니다.
access(): SpEL 표현식에 의한 결과에 따라 접근할 수 있습니다.
not(): 접근 제한 기능을 해제합니다.
permitAll() or denyAll(): 접근을 전부 허용하거나 제한합니다.
rememberMe(): 리멤버 기능을 통해 로그인한 사용자만 접근할 수 있습니다.
&lt;br /&gt;
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;출처: &lt;a href=&quot;https://postitforhooney.tistory.com/entry/SpringSecurity-초보자가-이해하는-Spring-Security-퍼옴&quot;&gt;PostIT&lt;/a&gt;
&lt;br /&gt;
&lt;br /&gt;
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;또한 이후에,&lt;/p&gt;
&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;formLogin&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;loginPage&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;/loginForm&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;loginProcessingUrl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;/login&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;defaultSuccessUrl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;이렇게 작성을 하게된다면, loginPage는 로그인 페이지가 어디인지, loginProcessingUrl은 login주소가 호출될 떄 시큐리티가 낚아채서 대신 로그인을 진행해주는 메소드이며,
.defaultSuccessUrl은 로그인 이후에 보여질 기본 페이지이며, 특정페이지로 접속하려 할 때 인증이 필요하여 로그인 페이지로 넘어갈 경우 그 로그인페이지에서 전에 config에서 설정해 놓은 기본 경로로
가지 않고 특정페이지가 보여지게 된다.
&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;b&gt;OAuth(2021-06-23추가)&lt;/b&gt;&lt;br /&gt;&lt;br /&gt;
OAuth2는 인증을 위한 표준 프로토콜이다.(정의) 
해당 인증으로 타 사이트의 API를 이용할 수 있게 되는 것이다.
스프링 시큐리티 라이브러리중 OAuth라는 라이브러리가 있었다. 예전 프로젝트를 할 때 네이버나 카카오 로그인 API를 사용할 때 개인 키를 적어두고 이를 사용해서 
토큰과 정보를 받아왔었다. 하지만, OAuth Client 라이브러리를 사용하니 그럴 필요없이 정해진 경로로 매핑을 해놓고, 키와 비밀번호를 property.yml에 저장해
놓으니, 굳이 토큰을 받아올 uri을 적고 가져오는 코드를 작성할 필요없이 로그인에 필요한 정보를 가져올 수 있었다.
예를 들어 구글 로그인 API를 사용할 경우 http://localhost:8080/login/oauth2/code/google 적었다고 하면, login/oauth2/code/은 고정이고 이후
google이나 facebook등은 해당 사이트에 맞게 적어주면 되었다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://developers.payco.com/guide/development/start&quot;&gt;페이코 개발자 센터&lt;/a&gt; 해당 링크에서 OAuth의 인증과정과 프로세스를 확인 할 수 있다.
&lt;br /&gt;&lt;br /&gt;
OAuth서비스 코드를 작성할 때 DefaultOAuth2UserService를 상속받아 사용하면 되며, loadUser 메소드를 오버라이드하여 안에 내용을 채워주면 된다.
&lt;br /&gt;&lt;br /&gt;
해당 유튜브 영상을 보며, 모르겠는 메소드를 찾아보았다.
&lt;br /&gt;&lt;br /&gt;
&lt;b&gt;userInfoEndpoint&lt;/b&gt;
OAuth2 로그인 성공 이후 사용자 정보를 가져올 때의 설정을 담당
&lt;br /&gt;&lt;br /&gt;
&lt;b&gt;userService&lt;/b&gt;
소셜 로그인 완료 후 후조치를 진행할 UserService 인터페이스의 구현체를 등록해줘야함
&lt;br /&gt;&lt;br /&gt;
후속 조치로는 데이터를 받아오면 바로 가입시켜주든 회원 가입 페이지로 이동을 시키든 할 수 있고, 아무래도 예전 프로젝트에서 사용하는 코드들 보다 많이
유용하고 편리하였다. 하지만 그래도 부트를 사용하기전 스프링에서 로그인 API사용하기 위한 코드를 직접 만들었던 적이 있어서 그런지 돌아가는 구조를 이해하는데
쉬웠다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3&gt;JWT를 들어가기 전에(2021=06-24)&lt;/h3&gt;
&lt;p&gt;JWT를 들어가기 전에 알아둬야 할 것이 있다고 유튜브 강의에서 나와서 정리를 해보려 한다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;
&lt;b&gt;Session과 Cookie&lt;/b&gt;
&lt;br /&gt;&lt;br /&gt;
우선 세션과 쿠키에 관하여 알아야 하는데, 이 부분은 전에 공부한 적이 있어서 어느정도 이해가 되어있는 상태로 보았다.&lt;br /&gt; 
쉽게 설명하자면, 세션은 서버가 기억하는 것이고, 쿠키는 사용자의 브라우저에서 기억하는 것이라고 생각할 수 있다.&lt;br /&gt;
우선 처음 사용자가 요청을 보내면 서버는 해당 사용자의 세션객체를 만들어 사용자에게 Header에 쿠키를 만들어 보내준다.&lt;br /&gt;
그럼 다음 사용자는 이후에 요청을 한다면 쿠키의 세션 아이디를 서버로 보내고 서버는 이 사용자가 전에 요청을 보낸적이 있는지 체크하게 된다.&lt;br /&gt;
&lt;br /&gt;&lt;br /&gt;
그런데, 서버에서 처리할 수 있는 요청이 50개인데 만약 70개의 요청이 들어온다면? 그럼 앞의 요청이 끝날 때까지 사용자는 기다려야 할 것이다. 이럴 경우, 
서버를 여러개 두어 요청이 초과할 경우 다른 서버로 이 요청을 보내주면 되는데, 이것을 로드 밸런싱이라고 한다.
&lt;br /&gt;
하지만 로드밸런싱을 할 경우 문제가 되는 부분이 있다. 바로 사용자는 처음 서버1에게 요청을 보내어 쿠키에 세션아이디를 가지고 있다고 가정하면, 로드 밸런싱으로
인하여 서버2에 요청이 갔을 경우 서버 2는 이 사용자를 처음 요청한 사용자로 볼 수 있다는 것이다.
&lt;br /&gt;&lt;br /&gt;
이런 문제를 해결하기 위하여 강의에서는 4가지를 말하였는데&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;처음 요청을 로드 밸런싱으로 처리할 경우 다음 요청은 처음 요청한 곳으로 가게한다.&lt;/li&gt;
  &lt;li&gt;각 서버가 세션을 공유하는 방법&lt;/li&gt;
  &lt;li&gt;세션을 데이터 베이스에 저장하는 방법&lt;/li&gt;
  &lt;li&gt;세션을 램서버에 저장하고 램서버를 각 서버가 공유하는 방법
&lt;br /&gt;&lt;br /&gt;
유튜브에서는 4번 방법이 제일 빠르다고 표현하였다. 자세한 부분은 접해볼 기회가 있다면 확인하고, 우선 이런거 까지만 있다정도로 확인하고 넘어가려 한다.
또한 jwt는 이 세션의 문제점을 보완하려고 나온 것이라고 한다.
&lt;br /&gt;&lt;br /&gt;
&lt;b&gt;CIA&lt;/b&gt;
CIA란,&lt;/li&gt;
  &lt;li&gt;C: 기밀성(Confidentiality)의 약자로  주고 받는 데이터가 비밀스러워야 한다는 것이다.&lt;/li&gt;
  &lt;li&gt;I: 무결성(Integrity)의 약자로, 데이터는 변하면 안된다.&lt;/li&gt;
  &lt;li&gt;A: 가용성(Availability)의 약자로, 가용성은 항상 특정한 방식에 의해 사용 가능하여야 한다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;하지만, 이 부분에서 만약 A가 B에게 “안녕”이라는 데이터를 전달하려고 한다. 하지만 A와 B사이에 나쁜 C가 있어서, 만약 A가 보냈을 때, C가 그 내용을
탈취하여 내용을 변경하거나, 탈취하고 소멸시켜 버릴 경우 B는 데이터를 받지 못하고, 데이터를 받았다고 하더라도 그 내용이 변경되어 잘 못 전달될 가능성이 있다.
그렇기 때문에 A는 데이터를 어떠한 박스에 넣고 그걸 자물쇠로 잠궈서 해당 열쇠로만 열리게 만들었다고 하면 C는 그걸 탈취하더라도 내용을 볼 수가 없다.
하지만, 문제가 생긴다. 잘 보내졌다고 하더라도 B는 열쇠가 없어 확인을 하지 못할 것이다. 그렇다고 A가 열쇠를 같이 보낸다면? C가 탈취하면 위와 같은 상황이
반복된다. 이렇다면 기밀성, 무결성, 가용성이 모두 침해당하게 된다.
&lt;br /&gt;&lt;br /&gt;
&lt;b&gt;RSA&lt;/b&gt;
&lt;br /&gt;&lt;br /&gt;
이렇기 때문에, 나온 방법이 RSA 암호화 방식이다. 이 방식은 공개키와 개인키로 이루어져 있고, 이런 방식을 symmetric-key algorithm 즉 대칭키 알고리즘이라고 한다.
위의 예시대로 A가 B에게 데이터를 전달하려고 할때, B가 공개해놓은 키로 암호화를 하여 A가 B에게 전송하면 C가 탈취하더라도 내용을 볼 수가 없다. 왜? 데이터는
B의 개인키로만 열 수 있기 때문에, 하지만 이럴 경우 C가 탈취해서 그냥 데이터를 소멸시켜버리고 새로운 데이터를 만들어 B에게 전송할 수도 있다. 이럴 경우,
B는 A가 만들줄 알고 데이터를 받을 것이고 내용을 확인 할 것이다. 
&lt;br /&gt;
그렇기 때문에, B의 공개키로 암호화된 데이터를 한번더 A의 개인키로 감싸는 것이다. 그렇다면, C가 탈취했다고 하더라도 A가 보낸 것을 알아도, 다시 A가 보낸 것처럼
만들 수 없다. 왜? A의 개인키를 모르기 때문에, 그렇다면, B는 데이터를 받았을 때 어떻게 확인하여야 할까. A가 미리 공개해둔 공개키로 열어 본다. 그렇다면, A가
보낸 것을 확인, 더불어 자신의 개인키로 내용을 확인할 수 있게 된다. 
&lt;br /&gt;&lt;br /&gt;
이렇게, CIA의 문제를 RSA로 해결하고 위의 사전지식을 가지고 JWT를 사용해보겠다. 
전에 기사공부를 하다가 기밀성 무결성 가용성 RSA 등의 암호화 방식을 공부했지만, 예를 들어 설명하니 조금 새롭게 다가왔고 정립이 된 것 같다. 좋군&lt;/p&gt;</content><author><name>Ko</name></author><category term="spring" /><summary type="html">기술 면접중 스프링 시큐리티에 관하여 질문을 받았고, 대답을 못했다. 돌아가는 모습은 내가 아는 모습은 비슷하지만, 지원을 해주는 것에서 많이 차이가 나는 것 같다. 편한기능이 많고, 알아두면 좋을 것 같다. 물론 어떻게 돌아가는지도 넣을 것이고, 자료는 유튜브 데어 프로그래밍님의 유튜브에서 가져왔고 설명이 잘되어 있는 것 같으니, 궁금할 땐 클릭해서 들어가 보자.(유튜브로 강의를 정말 잘해 놓으셨다.)</summary></entry><entry><title type="html">Algorithm Greedy(탐욕법)에 관하여</title><link href="https://sanseongko.github.io/algorithm-greedy" rel="alternate" type="text/html" title="Algorithm Greedy(탐욕법)에 관하여" /><published>2021-06-11T00:00:00+09:00</published><updated>2021-06-11T00:00:00+09:00</updated><id>https://sanseongko.github.io/algorithm-greedy</id><content type="html" xml:base="https://sanseongko.github.io/algorithm-greedy">&lt;p&gt;오늘은 알고리즘 중 하나인 Greedy에 관하여 알아보도록 하겠다.&lt;/p&gt;

&lt;h3&gt;Greedy&lt;/h3&gt;
&lt;p&gt;Greedy 탐욕법 알고리즘은 결과까지는 생각하지 않고 매 순간 최선이라고 생각되는 것을 선택해 결과까지 도달하는 알고리즘이다. 설명과 같이 매 순간 최
선인 선택을 하고 그 이후의 선택은 이후에 판단하기 때문에 언제나 옳은 알고리즘은 아닐 수 있다. 그렇기 때문에, 현상황에서 선택하는 최선의 수를 선택
한다면 결과도 최선이 되는 경우에 사용하여야 알맞다.
보통은 활동 선택 문제, 거스름돈 문제, 최소 신장 트리, 다익스트라 알고리즘에 활용이 가능하며, 살펴보다면 결국 매순간 최적의 선택을하고 그 선택들이
다음 선택과 전혀 무관하더라도 최적의 경우를 찾을 수 있는 문제에 사용이 가능한 것을 알 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;b&gt;탐욕범을 위한 문제&lt;/b&gt;
탐욕법의 정의이고, 나머지는 문제를 풀어보며 어떻게 접근하여야 할지 생각해 봐야하겠다. 추가적인 문제를 다룰 경우 추가 포스팅 예정임.&lt;/p&gt;</content><author><name>Ko</name></author><category term="algorithm" /><summary type="html">오늘은 알고리즘 중 하나인 Greedy에 관하여 알아보도록 하겠다.</summary></entry></feed>