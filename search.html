<!DOCTYPE html>
<html>
<head>

    <!-- Document Settings -->
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />

    <!-- Base Meta -->
    <!-- dynamically fixing the title for tag/author pages -->



    <title>Search Result</title>
    <meta name="HandheldFriendly" content="True" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <!-- Styles'n'Scripts -->
    <link rel="stylesheet" type="text/css" href="/assets/built/screen.css" />
    <link rel="stylesheet" type="text/css" href="/assets/built/screen.edited.css" />
    <link rel="stylesheet" type="text/css" href="/assets/built/syntax.css" />

    <!-- custom.css -->
    <link rel="stylesheet" type="text/css" href="/assets/built/custom.css"/>
    <!-- font awesome -->
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css">
    <!-- 웹폰트 추가 -->
    <link rel="stylesheet" href="https://fonts.googleapis.com/earlyaccess/nanumgothic.css">

    <!-- syntax.css 추가 -->
    <link rel="stylesheet" type="text/css" href="/assets/built/syntax.css"/>

    <!-- highlight.js -->
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css">
    <style>.hljs { background: none; }</style>

    <!--[if IE]>
        <style>
            p, ol, ul{
                width: 100%;
            }
            blockquote{
                width: 100%;
            }
        </style>
    <![endif]-->
    
    <!-- This tag outputs SEO meta+structured data and other important settings -->
    <meta name="description" content="온리 공부를 위한 블로그" />
    <link rel="shortcut icon" href="https://sanseongKo.github.io/assets/built/images/favicon.jpg" type="image/png" />
    <link rel="canonical" href="https://sanseongKo.github.io/search" />
    <meta name="referrer" content="no-referrer-when-downgrade" />

     <!--title below is coming from _includes/dynamic_title-->
    <meta property="og:site_name" content="SanseongKo's Blog" />
    <meta property="og:type" content="website" />
    <meta property="og:title" content="Search Result" />
    <meta property="og:description" content="온리 공부를 위한 블로그" />
    <meta property="og:url" content="https://sanseongKo.github.io/search" />
    <meta property="og:image" content="https://sanseongKo.github.io/assets/built/images/blog-cover1.jpg" />
    <meta property="article:publisher" content="https://www.facebook.com/" />
    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:title" content="Search Result" />
    <meta name="twitter:description" content="온리 공부를 위한 블로그" />
    <meta name="twitter:url" content="https://sanseongKo.github.io/" />
    <meta name="twitter:image" content="https://sanseongKo.github.io/assets/built/images/blog-cover1.jpg" />
    <meta name="twitter:label1" content="Written by" />
    <meta name="twitter:data1" content="SanseongKo's Blog" />
    <meta name="twitter:site" content="@" />
    <meta name="twitter:creator" content="@" />
    <meta property="og:image:width" content="2000" />
    <meta property="og:image:height" content="666" />

    <script type="application/ld+json">
{
    "@context": "https://schema.org",
    "@type": "Website",
    "publisher": {
        "@type": "Organization",
        "name": "SanseongKo's Blog",
        "logo": "https://sanseongKo.github.io/"
    },
    "url": "https://sanseongKo.github.io/search",
    "image": {
        "@type": "ImageObject",
        "url": "https://sanseongKo.github.io/assets/built/images/blog-cover1.jpg",
        "width": 2000,
        "height": 666
    },
    "mainEntityOfPage": {
        "@type": "WebPage",
        "@id": "https://sanseongKo.github.io/search"
    },
    "description": "온리 공부를 위한 블로그"
}
    </script>

    <!-- <script type="text/javascript" src="https://demo.ghost.io/public/ghost-sdk.min.js?v=724281a32e"></script>
    <script type="text/javascript">
    ghost.init({
    	clientId: "ghost-frontend",
    	clientSecret: "f84a07a72b17"
    });
    </script> -->

    <meta name="generator" content="Jekyll 3.6.2" />
    <link rel="alternate" type="application/rss+xml" title="Search Result" href="/feed.xml" />


</head>
<body class="page-template">

    <div class="site-wrapper">
        <!-- All the main content gets inserted here, index.hbs, post.hbs, etc -->
        <!-- < default -->
<!-- The tag above means: insert everything in this file
into the {body} of the default.hbs template -->

<!-- The big featured header, it uses blog cover image as a BG if available -->
<header class="site-header outer">
    <div class="inner">
        <nav class="site-nav">
    <div class="site-nav-left">
        
            
                <a class="site-nav-logo" href="https://sanseongKo.github.io/">SanseongKo's Blog</a>
            
        
        
            <ul class="nav" role="menu">
    <li class="nav-home" role="menuitem"><a href="/">Home</a></li>
    <li class="nav-about" role="menuitem"><a href="/about/">About</a></li>
    <li class="nav-jekyll" role="menuitem"><a href="/tag/algorithm/">Algorithm</a></li>
    <li class="nav-python" role="menuitem"><a href="/tag/python/">Python</a></li>
    <li class="nav-python" role="menuitem"><a href="/tag/java/">Java</a></li>
    <li class="nav-python" role="menuitem"><a href="/tag/interview/">기술 면접</a></li>
    <li class="nav-python" role="menuitem"><a href="/tag/codingtest/">코테 연습</a></li>
    <li class="nav-archive" role="menuitem">
        <a href="/archive.html">All Posts</a>
    </li>
    <li class="nav-archive" role="menuitem">
        <a href="/author_archive.html">Tag별 Posts</a>
    </li>
</ul>
        
    </div>
    <div class="site-nav-right">
        <div class="social-links">
            
            
        </div>
        
            <a class="subscribe-button" href="#subscribe">Search</a>
        
    </div>
</nav>

    </div>
</header>

<!-- Everything inside the #post tags pulls data from the post -->
<!-- #post -->

<main id="site-main" class="site-main outer" role="main">
    <div class="inner">

        <article class="post-full  post page no-image">

            <header class="post-full-header">
                <h1 class="post-full-title">Search Result</h1>
            </header>

            

            <section class="post-full-content">
                <form action="/search" method="get" hidden="hidden">
    <label for="search-box"></label>
    <input type="text" id="search-box" name="query">
</form>

<ul class="mylist" id="search-results"></ul>

<script>
    window.store = {
    
    "codingtest-2021-kakao01": {
        "title": "카카오 2021 블라인드 코딩테스트 1번",
            "author": "Ko",
            "category": "",
            "content": "문제카카오에 입사한 신입 개발자 네오는 “카카오계정개발팀”에 배치되어, 카카오 서비스에 가입하는 유저들의 아이디를 생성하는 업무를 담당하게 되었습니다.“네오”에게 주어진 첫 업무는 새로 가입하는 유저들이 카카오 아이디 규칙에 맞지 않는 아이디를 입력했을 때, 입력된 아이디와 유사하면서 규칙에 맞는 아이디를 추천해 주는 프로그램을 개발하는 것입니다.문제 자세히 보기풀이7가지의 조건들을 순서대로 적용하여 문제를 풀었다.순서대로 적용시키면 되기 때문에, 어렵진 않았지만 코드가 좀 더러운 느낌…?(멀었다… 멀었어…)깃허브에서 보기새로 알게된 메소드String id = new_id.toLowerCase();오 소문자로 바로 바꿔주더이다, 처음 생각한건 아스키 코드였는데 있다면 안 쓸 이유가 없지. 물론, new_id.toUpperCase();를 하면 대문자로 변환 해준다.(대문자, 소문자만 확인하여 변환하고 숫자나 기타 특수문자는 건들지 않아서 문제에 유용했다.)char[] a = answer.toCharArray();솔직히 몰랐다… 반복으로 char 배열에 넣어줘야 하는 줄 알았다…다 풀고나서, 다른 분의 풀이를 보았다… 잘한다… 정규 표현식",
        "url": "/codingtest-2021_kakao01"
    }
    ,
    
    "interview": {
        "title": "기술 면접 예상 질문",
            "author": "Ko",
            "category": "",
            "content": "기술 면접에 관하여, 내가 지원하려고 하는 자바, 스프링, 관련 지식 또는 CS관련 지식들을 적고 대답을 적어보는 포스팅을 하려고 한다.면접에 가서 모른다는 답변을 너무 많이했다… 아는 건데 막상 설명을 하려니 못하겠어서 찾아보고 정리하고 정확하게 말을 할 수 있을 정도가 되었으면 한다.자바면접 질문 중에 쓰레드에 관한 질문이 나왔고, 쓰레드를 알고 있었지 자바에서 구현 가능한지는 몰랐다. 하지만 찾아보니 써봤던 거다.자바에서 쓰레드내가 찾아본 자바에서 쓰레드는 보통 코드가 한번에 하나씩 실행이 된다고 한다. 그렇지만, 여기에 쓰레드를 상속받아 사용한다면, start() 메소드를 사용할 수 있고, start()가 실행될 때 run()를 수행하게 되어 있다.사용 이유보통은 동시에 많은 양의 요청이 들어오는 서비스에서, 그 요청들을 하나씩 처리한다면, 많은 시간이 소요가 될 것이다. 그렇게 많은 시간이 소요되는 부분을동시에 처리하여 시간을 줄이기 위하여 사용이 된다. 하지만 쓰레드가 많아질 경우 컴퓨터의 부하가 심해지고, [교착상태]가 날 수 있기 때문에 주의하여 사용을 해야한다.사용 예위의 결과 처럼 원래대로라면, 생성자를 생성하고 run()이 순차적으로 실행되어야 하는데, 유저가 랜덤하게 메세지를 보내고 있는 것을 확인할 수 있다.",
        "url": "/interview"
    }
    ,
    
    "algorithm-greedy": {
        "title": "Algorithm Greedy(탐욕법)에 관하여",
            "author": "Ko",
            "category": "",
            "content": "오늘은 알고리즘 중 하나인 Greedy에 관하여 알아보도록 하겠다.GreedyGreedy 탐욕법 알고리즘은 결과까지는 생각하지 않고 매 순간 최선이라고 생각되는 것을 선택해 결과까지 도달하는 알고리즘이다. 설명과 같이 매 순간 최선인 선택을 하고 그 이후의 선택은 이후에 판단하기 때문에 언제나 옳은 알고리즘은 아닐 수 있다. 그렇기 때문에, 현상황에서 선택하는 최선의 수를 선택한다면 결과도 최선이 되는 경우에 사용하여야 알맞다.보통은 활동 선택 문제, 거스름돈 문제, 최소 신장 트리, 다익스트라 알고리즘에 활용이 가능하며, 살펴보다면 결국 매순간 최적의 선택을하고 그 선택들이다음 선택과 전혀 무관하더라도 최적의 경우를 찾을 수 있는 문제에 사용이 가능한 것을 알 수 있다.탐욕범을 위한 문제탐욕법의 정의이고, 나머지는 문제를 풀어보며 어떻게 접근하여야 할지 생각해 봐야하겠다. 추가적인 문제를 다룰 경우 추가 포스팅 예정임.",
        "url": "/algorithm-greedy"
    }
    ,
    
    "java-restapipractice": {
        "title": "Java REST API 실습",
            "author": "Ko",
            "category": "",
            "content": "REST API를 너무 해보고 싶어 하나 하나 전부 뜯어 보려한다. 강의를 사서 볼까도 했지만, 오기가 생겨서 다 찾아보고 적어보려고 한다. 스프링 부트의 어노테이션에 관한 것도 같이 올릴 것이다. 또한 하루만에 완성하는 포스팅이 아니기 때문에, 수정날짜를 밑에 적도록 하겠다.@DataData어노테션의 경우 getter setter tostring hashcode equals전부 만들어주는 어노테이션으로 lombok 라이브러리에서 사용이 가능하며, @Getter, @Setter, @ToString, @EqualsAndHashCode 로 나누어 사용도 가능하며, get, set, toString, eqauls, hashcode 원하는 메서드를사용할 수도 있다.@NoArgsConstructor파라미터가 없는 생성자를 만들어주는 어노테이션이다.@AllArgsConstructor모든 파라미터로, 모든 필드에 대한 생성자를 만들어주는 어노테이션이다.@Entity@Entity는 DB의 테이블과 일대일로 매칭되는 객체의 단위이며, 기본 생성자가 필요하고, 필드에 final interface class를 사용할 수 없다. 또한 name을 주면 엔티티의 이름을 지정하고 @Entity가 붙은 클래스는 JPA에서 관리하게 된다.@Table(name = “”)@Table없이 테이블을 생성하게 될 경우 Entity 클래스의 카멜표기법을 유지한 상태로 테이블이 생성되기 때문에 작성해주는 것이 관례이다.@Id@Id어노테이션을 인스턴스에 붙이게 될 경우, PK와 같은 의미가 된다. 또한 @GerneratedValue를 사용할 경우 해당 변수의 수가 자동으로 증가하게 된다.(sequence와 같은 의미.)Spring Data JPA 쿼리 메소드안에 지원되는 키워드findBy 이런 형태가 쿼리 메소드 구문 이러면 자동으로 sql구문을 만들어 준다. 지원되는 키워드는 happygrammer님의블로그에 정리가 되어있어 링크해두겠다.OrElseThrow 메소드해당 메소드의 경우 java.util.Optiona을 임포트하여 사용이 가능하고, 실습 중에서는Optional org.springframework.data.repository.CrudRepository.findById(Integer id)메서드를 사용할 때 사용이 가능했다. 따로 에러처리를 해주지 않고, 에러가 날 경우 에러처리를 위한 클래스로 보내지는 메소드이다.추가적인 부분은 현재 The type org.springframework.util.MultiValueMap cannot be resolved. It is indirectly referenced from required .class files에러가 나서 이후에 올려보겠다.2021-06-11어제의 에러는 spring-core자르 파일이 문제가 있어 발생하여 외부에서 파일을 가져와 라이브러리를 추가하니 해결이 되었다.를 하자마자 새로운 오류 Consider defining a bean named ‘entityManagerFactory’ in your configuration. 발생, 해결하고 돌아와야지…이 부분은 톰캣 버전을 9로 맞춰주고 .m2폴더에 hibernate폴더를 지우고 다시 빌드하여 문제를 해결하였다.2021-06-12정의해 두었던 메소드를 사용하여 데이터를 삽입 실행시에 테이블을 생성하게 하여 실행하였을 때 데이터가 삽입되고, 테이블이 만들어지는 것을 확인,HeildiSql에데이터가 담기고 브라우저에 해당 데이터들이 제이슨형태로 보여지는 것까지 확인하였다. 예전 legacy로 한 프로젝트 안에서 모든걸 처리할 때, 컨트롤러의 리턴값을 JSP로 보내주었었는데, 이것을 레스트 API에선 리턴 값을 상태코드와 같이 보내주는 것을 보고, 머리속으로 그려지던게 조금 더 가까이 느껴졌다. 이제초석은 다졌으니 레스트 API의 제약 조건을 조금 더 알아보고 추가해보고 기존에 만들었던 프로젝트를 API화 시켜 REST방식으로 통신하는 것까지 진행해 보겠다.이 연습은 여기서 끝~2021-06-13HateoasRest Api의 제약 조건중 Hateoas의 제약 조건이 제일 맞추기 어려운 것을 보았다. Hypermedia As The Engine Of Application State의 약자이다.Hateoas는 링크를 통하여 어플리케이션의 상태가 전이되어야 하고, 링크에 자신의 정보가 담겨야 한다는 것이다. 이 말의 뜻은, 링크의 URI자원이 명시되어 있어야 하며, 클라이언트가 서버와 동적으로 상호작용이 가능하다는 말이다. 클라이언트가 서버에 POST요청을 보냈다고 가정했을 때, 이에 의존되는 GET, PUT, DELETE등의 URI를 Reponse에 포함하여 반환 시킨다. 응답 예:{  \"data\": {    \"id\": 1000,    \"name\": \"게시글 1\",    \"content\": \"HAL JSON을 이용한 예시 JSON\",    \"self\": \"http://localhost:8080/api/article/1000\", // 현재 api 주소    \"profile\": \"http://localhost:8080/docs#query-article\", // 해당 api의 문서    \"next\": \"http://localhost:8080/api/article/1001\", // 다음 article을 조회하는 URI    \"comment\": \"http://localhost:8080/api/article/comment\", // article의 댓글 달기    \"save\": \"http://localhost:8080/api/feed/article/1000\", // article을 내 피드로 저장  },}이 부분은 지켜지지 않고 있는 API들이 많으며, 스프링의 라이브러리를 사용하여 조금 더 쉽게 접근할 수 있기 때문에 다음엔, 라이브러리에서 제공하는 것을,사용하여 적용시켜 보겠다.출처: 오라클 자바 커뮤니티Wonit깃허브: sanseongKo",
        "url": "/java-restapipractice"
    }
    ,
    
    "algorithm-exhaustive-search": {
        "title": "Algorithm 완전 탐색에 관하여",
            "author": "Ko",
            "category": "",
            "content": "오늘은 알고리즘 중 하나인 완전 탐색 알고리즘에 대하여 알아보려고 한다.완전 탐색(Exhaustive Search)이란?완전 탐색이란, 가능한 경우의 수를 모두 구하여 답을 찾는 방법이다. 알고리즘이라고 하기 보단 답을 찾는 방법이라고 할 수 있다.답을 찾는 방법이고 경우의 수가 너무나도 많아질 경우엔 모든 경우의 수를 확인하는 것은 너무 어렵기 때문에 완전 탐색에 주로 사용되는 알고리즘 기법들또는 테크닉들이 있다.사용되는 알고리즘 기법, 테크닉완전 탐색의 경우 N의 크기가 작을 때, 시간 복잡도가 N의 지수승, 팩토리얼 꼴로 나올 때 많이 사용된다.단순 탐색알고리즘 기법을 사용하지 않고, 반복문과 조건문등을 이용하여 가능한 모든 경우를 만들어 답을 구하는 방법이다. 매우 비효율 적이기 때문에 가급적이면쓰이지 않는다.비트 마스크비트란, 컴퓨터에서 사용되는 2진 숫자로 되어있는 최소 단위이다. 이러한 이진수를 기반으로 0이면 true 1이면 false 혹은 2진수를 십진수로 표한 하는형태로 사용이 가능하다.예를 들면, 배열이 있고 그 배열의 부분만 들어있는 배열이 있다고 해보면,{1,2,3,4,5}{1,2,3}, {2,4,5}, {1,2}, {4,5}부분 집합의 배열을 전체 배열에 인덱스에 비교하여 boolean형태의 배열을 만들 수도 있다(ex.{1,2,3} =&gt; {1,1,1,0,0}). 하지만 이럴 경우 많은 메모리사용과 오버헤드를 증가시킬 수 있다. 따라서, 비트마스크를 이용하여 정수형태로 나타낼 수 있다.{1,2,3,4,5} =&gt; 11111(2) =&gt; 31{1,2,3} =&gt; 11100(2) =&gt; 28{2,4,5} =&gt; 01011(2) =&gt; 11{1,2} =&gt; 11000(2) =&gt; 24{4,5} =&gt; 00011(2) =&gt; 3이렇다고 한다면 {1,2,3}의 부분 집합의 배열은 28의 정수형태로 표현이 가능하다는 말이다.재귀 함수재귀 함수란 메소드에서 자기 자신을 다시 호출하여 작업을 수행하는 방식의 함수를 의미한다. 이렇듯, 같은 함수를 자기 자신이 계속해서 호출하여 모든 탐색을진행할 수 있다는 것과 동일하다. 다만, 메모리를 많이 차지하기 때문에 성능이 반복문에 비하여 느리고, 적절히 빠져나오지 못하게 만든다면, 무한히 호출하기때문에 코드를 짤 때 유의 해줘야한다.순열순열이란 서로 다른 n개의 집합에서 순서대로 늘어놓은 경우의 수를 얘기하며, 완전 탐색의 대표적인 유형이다. 또한, 재귀 함수를 이용하여 수를 채워나가지만,n이 커질 수록 처리시간이 길어지므로, n이 크기가 작아야한다. BFS(너비 우선 탐색)/DFS(깊이 우선 탐색)알고리즘도 같이 사용되긴하지만, 따로 다룰 생각이므로 다음 포스팅에서 소개하려고 한다.",
        "url": "/algorithm-Exhaustive-Search"
    }
    ,
    
    "algorithm-sort": {
        "title": "Algorithm 정렬에 관하여",
            "author": "Ko",
            "category": "",
            "content": "오늘은 정렬의 종류와 각 종류의 장단점에 대하여 알아보려한다. 여러가지 정렬이 있지만 기본적으로 그리고 내가 알고 싶은 정렬에 대하여 알아보려한다.선택 정렬(Selection Sort)선택 정렬은 집합 내에서 가장 작은 수를 선택하고 교환하는 것을 반복하는 정렬이다.처음 인덱스에서 제일 작은 수를 찾아 교환하게 된다. 그 이후 비교하는 수의 인덱스를 하나씩 늘려가며 작은 수를 찾는 것을 반복한다.선택 정령은 구현이 쉬운 편에 속하며, 비교 횟수는 많지만 교환 횟수는 적기 때문에 많은 교환이 자료 상태에서 효율적으로 사용된다.삽입 정렬(Insertion Sort)사진과 함께 이해하면 쉽다. 선택된 수와 그 수의 왼쪽과 비교하여 선택된 수보다 작은 수가 나올 때까지 정렬하는 방법이다.버블 정렬(Bubble Sort)버블 정렬은 선택된 값의 좌측 값이 선택된 값보다 크다면 교환하는 방법을 말한다.좌측 값만 비교하면 되기 때문에 구현이 단순하다.선택 정렬, 삽입 정렬, 버블 정렬 모두 O(N^2)의 시간 복잡도를 가지고 있다. 다만 실제로는, 선택 정렬이 버블 정렬보다 조금 더 빠르다. 또한,삽입 정렬의 경우 최선의 경우엔 O(N)의 시간복잡도를 가져 굉장히 빠른 정렬 방법이 될 수 있고, 이러한 이유로 다른 정렬 알고리즘의 일부로 사용되기도 한다.쉘 정렬(Shell Sort)쉘 정령은 선택 정렬과 개념이 같은데 차이가 있는 점은 쉘 정렬은 간격만큼 옆으로 이동한다는 것이다.사진에서 보이듯 간격을 설정하고 그 간격의 크기를 줄여나가면서 정렬을 해나간다. 시간복잡도는 평균 O(N^1.5)이자만 최악의 경우O(N^2)의 시간복잡도를 가지게 된다.퀵 정렬(Quick Sort)퀵 정렬은 축 값을 지정하고 그 축의 촤측 처음 인덱스 부터 오른쪽으로 이동하며, 자신보다 크거나 같은 값을 비교하여 교환하고 우측 끝 인덱스 부터 왼쪽으로 이동하며, 자신보다 작거나 같은 값을 비교하여 교환한다. 그 이후 사진에서 보이는 대로 left 인덱스가 right 인덱스보다 크다면 처음 배열을 분할한다.배열이 분리되면 축 값을 다시 잡고 위의 과정을 반복하여 정렬한다.시간 복잡도에서는 보통 O(NlogN)으로 실행 시간이 준수한 편이지만, 축값에 따라서 시간복잡도가 크게 달라지며, 최악(역순)일 경우 O(N^2)의 시간 복잡도를 가지기 때문에 축 값을 잘 지정하는 것이 좋다.병합 정렬(Merge Sort)병합 정렬은 분할할 부분의 값을 정하고 그 부분을 기준으로 최소 단위까지 나누어 병합시에 각 부분을 순차 비교 후 임시 배열에 삽입하고, 원래 배열에 임시 배열을 넣어준다. 이 과정을 반복하는 것이 병합 정렬이다.퀵 정렬과 비슷하게 원래 배열을 나누어 정렬하는 정렬 법이다. 그렇기 때문에 분할하는 과정에서 logN만큼의 시간이 걸리고 결국 O(NlogN)의 시간 복잡도를가지게 된다. 다만, 퀵 정렬과 달리 분할해줘야 하는 기준점 설정없이 절반으로 나누어 분할하기 때문에 기준점에 따라 시간이 증가하거나 줄어들지 않는다.따라서 항상 같은 시간복잡도를 가지게 되고 안정성이 있기 때문에, 정렬법들중 준수한 정렬 법이다. 하지만, 분할하여 임시배열에 배열을 분할된 배열을 저장하다보니, 추가적인 메모리가 필요하고, 이를 기준으로 퀵을 써야할지 병합을 써야할지 기준을 정하면 된다.힙 정렬(Heap Sort)힙정렬은 힙알고리즘을 기본으로 짜여진 정렬이다. 그렇다면 루트 노드에는 항상 제일 우선순위인 값이 삽입되어 있을 것이다. 그렇다면 그 루트를 출력하고힙에서 제거한다. 이 과정을 반복하여 정렬하는 방법이다.힙 정렬은 추가적인 메모리를 필요로 하지 않기 때문에, 항상 O(NlogN)의 시간 복잡도를 보여준다.출처: https://namu.wiki/w/%EC%A0%95%EB%A0%AC%20%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98출처: https://yabmoons.tistory.com/250 [얍문’s Coding World..]출처: https://roka88.dev/98 [이병록의 개발 블로그]",
        "url": "/algorithm-sort"
    }
    ,
    
    "java-restapi": {
        "title": "Java RESTful API 개념 정리",
            "author": "Ko",
            "category": "",
            "content": "오늘은 RESTful API에 대하여 정리해보려고 한다.RESTful API를 알기전에 REST와 RESTful의 차이를 알아야 한다.REST란, 분산시스템 설계를 위한 아키텍처 스타일이다. 즉, 제약 조건의 집합이라고 볼 수 있다. 그렇다면, RESTful은 무엇일까? RESTful은 제약조건의 집합 즉, 아키텍처 스타일, 아키텍처 원칙을 모두 만족하는 것을 의미한다.RESTful APIRESTful API는 REST 아키텍처 원칙을 모두 만족하는 API라고 할 수 있다.또한, 인터넷과 웹을 통해 나의 컴퓨터를 제어할때 어떻게하면 시행착오를 줄이고 더 좋은 API를 만들수 있는가에 대한 고민이다.RESTful API는 특정기술 지칭하는 것이 아니라, HTTP를 이용하여 기계들이 통신할때 HTTP가 가진 잠재력을 최대한 끌어낼 수 있는 모범사례라고 할 수 있다. HTTP메서드들을 본래 용도에 맞게 쓰자는 것도 중요한 목적RESTful API의 구성요소Resource(자원)데이터들을 Resource라고 하고, REST API는 URI(정보를 식별하는 이름일뿐) 로 표현된다.Collection : Element 의 집합(복수형)Element: 콜렉션에서 하나하나의 데이터(단수형)URI를 가공하는 방법Method(행위)또한, 보통의 웹페이지간의 데이터 전송은 Post로 이루어지는 경우가 많다. REST는 HTTP메소드를 최대한 활용하는 아키텍처 스타일이다.그렇기 때문에, REST는 HTTP메소드를 알맞은 곳에 사용하기를 원한다. 밑의 내용은 HTTP메소드의 원래의 기능을 알려준다.Create -&gt; postRead -&gt; getUpdate -&gt; put(전체), patch(부분)Delete -&gt; deleteMicrosoft REST API Guidelines에서는 HEAD와 OPTIONS메소드도 알려주고 있다.HEAD는 READ(GET) 응답을 위해 객체의 메타데이터를 리턴해주는 것이며, OPTION은 요청 정보를 얻는 것 즉, 도움말 정도로 볼 수 있을 것 같다. 여기서 put과 patch의 방식이 조금 혼동될 수 있지만, patch는 다른 데이터에 영향을 주지 않고 해당 데이터만 변한다면, put은 변경하려는 데이터를제외하고는 삭제가 되는 차이를 예로 들 수 있다.(patch는 부분을 수정, put은 전체 수정)REST 특징(제약 조건)Server-Client(서버-클라이언트 구조)    REST서버는 API를 제공, Client는 사용자 인증이나 세션,로그인 정보등을 직접 관리하는 구조로 서버와 클라이언트 사이의 역할이 확실히 구분됨    그로인하여, 개발할 내용이 명확해지고 서로간 의존성이 줄어들게 된다.Stateless(무상태성)작업을 위한 상태정보를 따로 저장하거나 관리하지 않는다. 따라서 들어오는 요청을 단순히 처리만 하면된다. 이로인하여 서비스의 자유도가 상승 서버의불필요한 정보를 관리하지 않기 때문에 구현이 단순해진다.Cacheable(캐시 처리 가능)HTTP의 기존 웹표준을 그대로 이용하기 때문에, 웹에서 사용하는 기존 인프라를 그대로 활용이 가능하다. 따라서 HTTP의 캐싱기능을 적용할 수 있는 것이다. (캐싱구현은 HTTP표준에서 사용하는 Last-Modified태그나 E-Tag를 이용하면 캐싱 구현이 가능하다.)Layered System(계층형 구조)REST 서버는 다중 계층으로 구성될 수 있으며 보안, 로드 밸런싱, 암호화 계층을 추가해 구조상의 유연성을 둘 수 있고 PROXY, 게이트웨이 같은 네트워크 기반의 중간매체를 사용할 수 있게한다.Uniform Interface(인터페이스 일관성)Uniform Interface는 URI로 지정한 리소스에 대한 조작을 통일되고 한정적인 인터페이스로 수행하는 아키텍처 스타일을 말한다.Self-descriptivenessREST API의 메세지만 보고도 이를 쉽게 이해할 수 있는 자체 표현 구조로 되어 있다.출처[정아마추어 코딩블로그](https://jeong-pro.tistory.com/180#:~:text=REST%EB%8A%94%20%EB%B6%84%EC%82%B0%20%EC%8B%9C%EC%8A%A4%ED%85%9C%20%EC%84%A4%EA%B3%84,%EB%A7%8C%EC%A1%B1%ED%95%98%EB%8A%94%20%EA%B2%83%EC%9D%84%20%EC%9D%98%EB%AF%B8%ED%95%9C%EB%8B%A4.)https://gmlwjd9405.github.io/2018/09/21/rest-and-restful.html/rest-and-restful.htmlhttps://meetup.toast.com/posts/92[생활코딩님의 기계들의 대화법 - REST API](https://www.youtube.com/watch?v=PmY3dWcCxXI)",
        "url": "/java-restapi"
    }
    ,
    
    "algorithm-heap": {
        "title": "Algorithm Heap에 관하여",
            "author": "Ko",
            "category": "",
            "content": "오늘은 자료구조 힙에 관하여 알아보자.완전 이진 트리힙 자료구조를 알아보기 전에 완전 이진 트리에 관하여 알아둬야 할 필요가 있다. 완전 이진 트리란 이진 트리증 왼쪽부터 차례대로 채워져 있는 트리를 의미한다. 사진으로 보면 더욱 쉽게 이해가 가능하다.위 사진에서 왼쪽은 왼쪽부터 차례대로 채워져 있는 상태이므로 완전 이진 트리라 할 수 있으며, 사진의 오른쪽은 왼쪽 노드가 다 채워져 있지 않은 상태이기 때문에 완전 이진 트리가 아니다.힙(Heap) 자료구조자료 구조 힙이란, 완전 이진 트리의 일종으로 우선순위 큐를 구현할때 자주 사용되는 알고리즘이다. 또한, 여러개의 값들 중 최댓값이나 최솟값을 빠르게찾아낼 수 있도록 만들어진 자료구조이다. 힙은 일종의 반정렬 상태를 유지하며, 중복된 값을 허용한다.힙에서 부모 노드와 자식 노드의 관계는 아래의 규칙을 따른다.  왼쪽 자식의 인덱스 = (부모의 인덱스)*2  오른쪽 자식의 인덱스 = (부모의 인덱스)*2+1  부모의 인덱스 = (자식의 인덱스)/2힙의 종류-최대 힙          부모 노드의 키 값이 자식 노드의 키 값보다 크거나 같은 완전 이진트리를 의미한다.-최소 힙      부모 노드의 키 값이 자식 노드의 키 값보다 작거나 같은 완전 이진 트리를 의미한다.      힙의 삽입 과정  힙에 새로운 요소가 들어오면, 힙의 마지막 노드에 이어서 삽입하게 된다.  새로운 노드를 부모노드들과 교환하여 힙의 성질을 만족시킨다.아래의 과정으로 확인할 수 있다.힙의 삭제 과정  최대 힙에서 최대값은 루트 노드(1번노드)이므로 루트노드가 삭제된다  삭제된 루트 노드엔 힙의 가장 마지막 노드를 가져와서 위치 시킨 뒤  자식 노드들과 비교하여 힙을 재구성한다.아래의 과정으로 확인할 수 있다.",
        "url": "/algorithm-heap"
    }
    ,
    
    "java-orm": {
        "title": "Java ORM이란?",
            "author": "Ko",
            "category": "",
            "content": "MyBatis를 사용하다가 ORM이라는 것을 듣게 되었다. 너무 궁금하니 한번 알아보자.ORM이란?Object Relational Mapping, 말 그대로 객체-관계 매핑이라는 것이다.다만 RDB는 테이블로 이루어져 있고, OPP 객체지향 프로그래밍에서는 클래스를 사용하게 된다. 하지만 객체와 관계형 데이터베이스가 애초에 호환을 염두하고 만들어 진 것이 아니다보니, 자연스럽게 불일치가 발생하게 된다. 이럴때 ORM을 사용하여 객체의 관계를 바탕으로 SQL문을 자동적으로 생성 불일치를 해결한다.객체 - 관계 간의 불일치그렇다면 객체-관계간의 불일치는 왜 생기게 될까? 이유는 5가지로 분류할 수 있다.1. 세분성(Granularity)경우에 따라서 데이터베이스에 있는 테이블 수보다 더 많은 클래스를 가진 모델이 생길 수 있다.(RDB 데이터 타입은 Vendor마다 다르며, 더이상 정규화가 힘들다.)2. 상속성(Inheritance)RDBMS는 객체지향 프로그래밍 언어의 특징인 상속 개념이 없다.3. 일치(Identity)RDBMS는 기본키(primary key)를 이용하여 동일성을 정의한다. 그러나 자바는 객체 식별(a==b)과 객체 동일성(a.equals(b))을 모두 정의한다.4. 연관성(Associations)객체지향 언어는 방향성이 있는 객체의 참조(reference)를 사용하여 연관성을 나타내지만 RDBMS는 방향성이 없는 외래키(foreign key)를 이용해서 나타낸다.5. 탐색(Navigation)자바와 RDBMS에서 객체를 접근하는 방법이 근본적으로 다르다. 자바는 그래프형태로 하나의 연결에서 다른 연결로 이동하며 탐색한다. 그러나 RDBMS에서는 일반적으로 SQL문을 최소화하고 JOIN을 통해 여러 엔티티를 로드하고 원하는 대상 엔티티를 선택하는 방식으로 탐색한다.ORM의 장점과 단점장점  객체 지향적인 코드로 인해 더 직관적이고 비즈니스 로직에 더 집중할 수 있게 도와준다.          선언문, 할당, 종료 같은 부수적인 코드가 없거나 급격히 줄어든다.      각종 객체에 대한 코드를 별도로 작성하기 때문에 코드의 가독성을 올려준다.      SQL의 절차적이고 순차적인 접근이 아닌 객체 지향적인 접근으로 인해 생산성이 증가한다.        재사용 및 유지보수의 편리성이 증가한다.          ORM은 독립적으로 작성되어있고, 해당 객체들을 재활용 할 수 있다.      때문에 모델에서 가공된 데이터를 컨트롤러에 의해 뷰와 합쳐지는 형태로 디자인 패턴을 견고하게 다지는데 유리하다.      매핑정보가 명확하여, ERD를 보는 것에 대한 의존도를 낮출 수 있다.        DBMS에 대한 종속성이 줄어든다.          대부분 ORM 솔루션은 DB에 종속적이지 않다.      종속적이지 않다는것은 구현 방법 뿐만아니라 많은 솔루션에서 자료형 타입까지 유효하다.      프로그래머는 Object에 집중함으로 극단적으로 DBMS를 교체하는 거대한 작업에도 비교적 적은 리스크와 시간이 소요된다.      또한 자바에서 가공할경우 equals, hashCode의 오버라이드 같은 자바의 기능을 이용할 수 있고, 간결하고 빠른 가공이 가능하다.단점        완벽한 ORM 으로만 서비스를 구현하기가 어렵다.          사용하기는 편하지만 설계는 매우 신중하게 해야한다.      프로젝트의 복잡성이 커질경우 난이도 또한 올라갈 수 있다.      잘못 구현된 경우에 속도 저하 및 심각할 경우 일관성이 무너지는 문제점이 생길 수 있다.      일부 자주 사용되는 대형 쿼리는 속도를 위해 SP를 쓰는등 별도의 튜닝이 필요한 경우가 있다.      DBMS의 고유 기능을 이용하기 어렵다. (하지만 이건 단점으로만 볼 수 없다 : 특정 DBMS의 고유기능을 이용하면 이식성이 저하된다.)        프로시저가 많은 시스템에선 ORM의 객체 지향적인 장점을 활용하기 어렵다.          이미 프로시저가 많은 시스템에선 다시 객체로 바꿔야하며, 그 과정에서 생산성 저하나 리스크가 많이 발생할 수 있다.      결국 편하자고 사용하는 것이고, 객체지향다운 프로그래밍을 하자는 것이다. 다만, 장점과 단점에서 보았듯이, 원래 OOP와 RDB가 서로를 위하여 만들어 진 것이 아닌 만큼 ORM을 사용하는 framework들을 사용하는 것도 좋지만, 정확하게 알고 사용해야 하고, 추가적으로 ORM의 한계 혹은 성능저하가 일어나는 부분에 대하연 추가적인 공부 및 알게된다면 다시 추가 포스팅을 해야할 것 같다.출처 https://geonlee.tistory.com/207 [빠리의 택시 운전사]장점과 단점",
        "url": "/java-orm"
    }
    ,
    
    "java-jpa": {
        "title": "Java JPA란?",
            "author": "Ko",
            "category": "",
            "content": "",
        "url": "/java-jpa"
    }
    ,
    
    "algorithm-stackqueue": {
        "title": "Algorithm Stack and Queue에 관하여",
            "author": "Ko",
            "category": "",
            "content": "오늘은 스택과 큐라는 알고리즘을 알아보도록 하겠다. 스택과 큐를 같이 묶어서 포스팅하는 이유는 비슷한 느낌이자만 차이가 분명하게 존재하기 때문이다.스택(Stack)이란?스택은 Last In First Out (LIFO), 즉 후입선출구조를 가지고 있다.또한, 한쪽에서 삽입과 삭제가 이루어 지는 구조이기도 하다.위의 사진은 흔히 볼 수 있는 스택의 형태를 가지고 있고, push는 자료의 삽입, pop은 자료의 배출이라고 보면 된다. 사진에서도 볼 수 있듯 한쪽에서 삽입되고, 한 쪽에서 삭제가 되는 것을 볼 수가 있다.그럼 스택은 어디서 쓰일까? 예를 들자면, 브라우저의 뒤로가기 버튼을 생각하면된다. 가장 마지막에 거쳐온 곳을 보여줘야하니 제일 마지막의 정보를제일 처음 보여준다와 의미가 통한다.큐(Queue)란?큐는 스택과 다르게 First In First Out(FIFO) 즉, 선입선출구조를 가지고 있다. 스택은 한쪽에서 삽입과 삭제가 일어난다고 했는데, 그렇다면 큐는?큐는 제일 먼저들어간 것이 제일 처음 나오게 되므로, 삽입되는 곳에서는 이미 마지막으로 들어온 것이 버티고 있어 나가지 못한다. 그렇기 때문에 한쪽 끝(front)에서삽입되어 다른 쪽 끝(rear)에서 삭제된다.사진으로 보아도 스택과는 다르게 push되는 곳과 pop되는 곳의 위치가 다른 것을 확인할 수 있다.그럼 큐는 어디서 쓰일까? 예를 들자면, 대기줄이 필요할때 먼저온 사람이 먼저 정보를 받는 형태 또는 데이터 유입속도가 데이터 소모속도 보다빠를때 쓰일 수 있다.Java에서 Stack 사용법Stack 선언import java.util.Stack;Stack stack = new Stack&lt;elelment&gt;();//element는 스택에 담기는 자료형이 어떤 자료형인지Stack 값 삽입stack.push(값);Stack 값 삭제stack.pop();//제일 마지막에 들어간 수 출력과 삭제stack.clear();//스택에 저장되어 있는 전체 값 삭제Stack 처음 나올 값 확인stack.peek();//값만 출력 삭제xStack의 기타 메소드stack.size();//스택의 크기 출력(ex.값이 2개들어 있다면 2를 출력)stack.empty();//스택이 비어 있는지 체크stack.contains(값);//스택에 해당 값이 있는지 체크(boolean으로 리턴)Java에서 Queue 사용법Queue 선언import java.util.LinkedList;import java.util.Queue;Queue queue = new LinkedList&lt;elelment&gt;();//element는 큐에 담기는 자료형이 어떤 자료형인지자바에서 큐는 LinkedList로 객체선언을 해주어야 사용이 가능함을 잊지말자.Queue 값 삽입queue.offer(값);//삽입에 성공하면 true를 반환하고, 큐에 여유 공간이 없어 삽입에 실패하면 IllegalStateException을 발생Queue 값 삭제queue.poll();//제일 마지막에 들어간 수 출력과 삭제(비어있다면 null)queue.remove();//큐에 첫번째 값 제거queue.clear();//큐 초기화Queue 처음 나올 값 확인queue.peek();//값만 출력 삭제x",
        "url": "/algorithm-stackqueue"
    }
    ,
    
    "java-evshash": {
        "title": "Java .equals(), hashcode(), ==의 차이점",
            "author": "Ko",
            "category": "",
            "content": "오늘은 많이 쓰지만 그래서 이게 뭐가 다르지 했던 ==연산자와 equals()메소드와 hashcode()메소드의 차이에 대하여 알아볼까?호롤ㄹ로로ㄹㄹㄹ1. 자바에서의 ==연산자==연산자는 비교하는 값이 primitive type(int, double, boolean 등등) 일때는 값이 같은지 비교 하고 그 외의 객체, reference type(Array, Class 등등)일 때는 가리키는 주소가 같은지 비교하고 리턴값은 같으면 true, 다르면 false이다.위와 같이 String으로 변수 선언할 경우 reference type이지만 메모리의 힙영역에 “String”이라는 값이 할당되고 a,b모두 할당된 주소 값을 참조하기 때문에 true가 반환된다.String a = new String(\"String\");String b = new String(\"String\");하지만 위의 코드와 같이 생성자를 이용하여 각 a,b가 각 각각 따로 힙영역에 값을 할당 받을 경우 주소 값이 다르기 때문에 false가 출력된다.배열의 경우에도 안의 내용이 같더라도 힙영역에 따로 선언되기 때문에 false가 출력된다.이와 같이, primitive type일땐 값을 비교, reference type일땐 힙영역에 할당된 주소 값을 비교한다.2. 자바에서의 .equals()equals() 메소드(Object 클래스의 메소드)의 경우 쉽게 말하면 내용을 비교한다.(배열의 경우 위의 코드에서 array1.equals(array2)라하면 false가 나온다)정확하게는 equals메소드에 정의되어 있는 내용대로 값들을 비교해 나간다. 스트링의 equals메소드에 대한 글은 코딩하는 흑구이분이 정리를 잘해주신 것 같다. 배열의 경우 Arrays 클래스를 import하여 그 안에 있는 equals메소드를 써야한다.다만, 내용이 동일하더라도 안에 값이 같은지 확인을 못할 경우가 있다.예를 들면,public class Person {    private String name;    private int age;        public String getName() {        return name;    }    public void setName(String name) {        this.name = name;    }    public int getAge() {        return age;    }    public void setAge(int age) {        this.age = age;    }    public Person(String name, int age) {        super();        this.name = name;        this.age = age;    }    @Override    public String toString() {        return \"Person [name=\" + name + \", age=\" + age + \"]\";    }}이렇게 Person객체를 만들어 아래 정보를 삽입하였다면,Person person1 = new Person(\"name\", 27);Person person2 = new Person(\"name\", 27);System.out.println(person1 == person2);//falseSystem.out.println(person1.equals(person2));//falseperson1 == person2는 당연히 false가 나올 것이지만, person.equals(person2)도 false가 나오게 된다. 이는 안의 내용중 name만 맞아도 같은 것으로봐야하는지 아니면 27까지도 같이 확인을 해야하는지 모르기 때문이다. 이럴 경우에 equals메소드를 오버라이딩하여 다시 정의 해주도록 하자.3. 자바에서의 .hashCode()equals메소드하면 항상 같이 나오는 것이 hashCode()이다. 왜냐하면, 안에 내용이 같더라도 각 객체의 해시코드가 다를 경우가 있기 때문이다. 예를들어,위의 경우에서 equals를 다시 정의하여 같은 값으로 볼 수 있게 정의하였다고 하여도 hash함수를 쓰는 객체가 있다면, 이를 다른 객체로 볼 수 있기 때문이다.예를 들어, HashSet은 중복을 제거하고 저장해주는 클래스이다. 하지만 person1과 person2를 HashSet안에 담을 경우 해쉬코드가 다르기 때문에 다른 객체라고판단, 따로 담아 저장해둔다. 이럴 경우도 대비하여 equals메소드를 오버라이딩할때 HashCode도 같이 재정의하여 문제가 없도록 하여야 한다.출처https://jeong-pro.tistory.com/172 [기본기를 쌓는 정아마추어 코딩블로그]https://sas-study.tistory.com/280 [코딩하는 흑구]",
        "url": "/java-evshash"
    }
    ,
    
    "algorithm-dynamicprogramming": {
        "title": "Algorithm 동적 계획법에 관하여",
            "author": "Ko",
            "category": "",
            "content": "동적 계획법동적 계획법이란, 보다 큰 문제를 작은 문제로 나누어 푸는 방식을 뜻한다. 이 부분은 분할과 정복과 유사한데, 분할과 정복은 중복이 절대 일어날 수 없다는 것이고, 동적 계획법에서는 문제가 중복된다는 점이다. 이 부분에서 동적 계획법은 중복으로 일어난 작은 문제에 대하여 그 문제에 사용되었던 방식을, 값을캐시(cache)라 불리는 메모리에 미리 넣어두고 중복되는 문제를 마주칠 시에 미리 저장되어 있던 값을 꺼내어 사용하는 것이다.(Memoization 메모이제이션)위의 사진에서 보이는 대로 f(3)의 f(2)의 검은색 부분이 겹치기 때문에, 이 값들은 캐시에 저장해두고 쓸 수 있다. 미리 값을 정해두고 계산을 하는 것이기때문에 시간이 단축된다.동적 계획법 조건동적 계획법은 2가지 조건을 만족하여야 동적 계획법으로 문제를 풀 수 있다. 첫 번째는, 겹치는 부분이 있어야하고(overlapping subproblem), 최적의부분 구조가 있어야 한다.1. Overlapping Subproblem보통은 피보나치 수열을 예로들어, 이 부분을 설명할 수 있다. 피보나치 수열의 경우, Fn = F(n-1)+F(n-2)의 즉, 앞의 두수를 더하면 다음 수가 되는 것이다.이럴 경우, 재귀함수로 표현할 시 return 값이 f(n-1)+f(n-2)로 본인의 메소드를 다시 불러오게 된다.(n=인자값) 앞의 두수는 이미 앞에서 계산할 때 계산이 된 수이므로, 다시 계산할 필요없이 cache에 담아두고 빠르게 찾아쓰자는 것이다. 이렇게 겹치는 부분이 우선 존재해야 한다.2. Optimal Substructure최적 부분 구조는 어떤 문제의 최적의 해결책이 그 부분 문제의 최적의 해결책으로 부터 설계될 수 있다는 것을 가르킨다. 피보나치를 예로 들자면 100번째 항은항상 99과 98의 합과 같다. 또한, 각각 99와 98은 98과97의 합 97과 96의 합과 같다. 이렇듯, 부분의 문제의 해결책이 보다 큰 문제의 해결책이 되는 경우가이에 해당한다.동적 계획법 구현 방식1. Top-down말그대로 위에서 부터 아래로, 큰 문제(Fn)를 작은 문제(F(n-1)+F(n-2)로 나누어 작은 문제부터 풀고 큰 문제를 푸는 것을 가르킨다. 피보나치 수열을 계산할 떄 재귀함수로 푸는 것이 이에 해당한다.2. Bottom-up탑 다운과 반대로 문제 크기가 작은 것부터 큰것으로 푼다. 작은 것부터 차례대로 풀었기 때문에 큰 문제를 당연히 풀 수 있으며, 반복하면 가장 큰 문제를풀 수 있게 된다. 보통 피보나치 수열에선 for문을 사용하여 i가 2부터 n까지(0과 1은 정해져 있음) 작은 문제부터 풀어 나가게 된다.",
        "url": "/algorithm-dynamicprogramming"
    }
    ,
    
    "algorithm-hash": {
        "title": "Algorithm Hash에 관하여",
            "author": "Ko",
            "category": "",
            "content": "오늘은 Hash에 대하여 정리를 해보려고 한다.주 언어가 Java이다보니 HashMap은 많이 써보았지만, 정확하게 정리를 해본적은 없는 듯하여 정리를 해보려한다.내가 알고 있던 Hash에선 키와 값이 있으며, 키를 인덱스로 가지고 있기 때문에 시간복잡도가 O(1)이라는 것.1 해시  해시는 임의의 크기를 가진 데이터를 고정된 데이터 크기로 변화시키는 것을 말하며,  해시함수를 사용하여 값을 계산하여 나온 고정된 길이의 값을 해시값이라고 부른다.  여러 분야에 사용되며, 복잡하지 않은 알고리즘으로 이루어져 CPU,메모리 등 시스템 자원을 덜 소모한다고 한다.  여러분야 사용되고 여러가지(MDn, SHA-n 등) 해시 알고리즘이 있지만(자세하게 다룰일이 있으면 추가해야지)2 해시 충돌해시 충돌은 해시함수를 거친 키값이 같은 값들. 즉, 다른 데이터의 키 값(해시값)들이 동일할 경우 해시 충돌이 발생한다.이 충돌은 해시 테이블의 성능을 떨어뜨린다. 해시 충돌을 방지하려면 해시 함수를 잘 정의하면 된다. 하지만 해시함수의 입력값은 무한하지만, 출력값의 가짓수는 유한(출력값, 즉 키가 유한하지 않다면 해시기법을 사용하는 의미가 없다.)하므로 해시 충돌은 반드시 발생한다.(비둘기집 원리)이러한 해시충돌을 방지할 방법은 크게 2가지가 있다.체이닝(Chaining)버킷내에 LinkedList를 할당하여, Bucket에 데이터를 저장하다가 해시 충돌이 발생하면 연결리스트로 데이터를 연결하는 방식이다.개방 주소법(Open Addressing)해시 충돌이 발생하면 다른 Bucket에 데이터를 삽입하는 방식이다.체이닝은 주소값은 동일한 상태로 LinkedList를 이용하여 늘려가기 때문에, 주소값이 변경되지는 않는다는 부분과 차이가 있다.3가지 개방 주소법  선형 탐색&lt;/b&gt;: 해시 충돌 시 다음 버킷 혹은 몇개를 건너뛰어 데이터를 삽입  제곱 탐색&lt;/b&gt;: 해시 충돌 시 제곱만큼 건너뛴 버켓에 데이터를 삽입  이중 해시&lt;/b&gt;: 해시 충돌 시 다른 해시 함수를 한 번 더 적용한 결과를 이용해시를 이용한 자료구조해시를 이용한 자료구조엔 HashMap, HashTable이 있다.둘의 차이는 동기화 지원이 가능하냐 안하냐의 차이(synchronized)가 있다고 한다.해시 자료구조의 시간 복잡도해시함수로 만들어진 키값들은 고유한 인덱스를 가지게 되어 바로 접근할 수 있다.그러므로 평균 O(1)의 시간복잡도를 가지고 있지만, 데이터 충돌이 발생할 경우 Chaining에 연결된 리스트들까지검색해야 하므로 O(N)까지 시간복잡도가 증가할 수 있다.충돌을 방지하는 방법들은 데이터의 규칙성(클러스터링)을 방지하기 위한 방식이지만 공간을 많이 사용한다는 치명적인 단점이 있다.만약 테이블이 꽉 차있는 경우라면 테이블을 확장해주어야 하는데, 이는 매우 심각한 성능의 저하를 불러오기 때문에 가급적이면 확장을 하지 않도록 테이블을 설계해주어야 한다.(통계적으로 해시 테이블의 공간 사용률이 70% ~ 80%정도가 되면 해시의 충돌이 빈번하게 발생하여 성능이 저하되기 시작한다고 한다.)또한 해시 테이블에서 자주 사용하게 되는 데이터를 Cache에 적용하면 효율을 높일 수 있다. 자주 hit하게 되는 데이터를 캐시에서 바로 찾음으로써 해시 테이블의 성능을 향상시킬 수 있다출처 https://mangkyu.tistory.com/102 [MangKyu’s Diary]https://preamtree.tistory.com/20 [Preamtree의 행복로그]",
        "url": "/algorithm-hash"
    }
    ,
    
    "newposting": {
        "title": "첫 포스팅!",
            "author": "Ko",
            "category": "",
            "content": "우역곡절 끝에 지킬을 이용하여 깃허브 블로그 페이지를 만들었다.(travis ci는 하다가 포기…)공부를 하다보니 까먹는게 너무 많아지고 알았던 개념도 까먹는 상황이 너무 빈번해지다보니, 그리고 히키코모리마냥 혼자 정리된 문서를 가지고 있는 것 보단 블로그하나 만들어서 거기에 전부 담으면서 정리하는게 나아 보였다.점차 나아지는 부분도 눈으로 보일테니 더욱 좋아보인다.자, 이제 공부만을 위한 포스팅을 시작해야지 끌끌.",
        "url": "/newPosting"
    }
    ,
    
    "python-control-statement": {
        "title": "Python 강좌(2) - Python 제어문",
            "author": "sanseongKo",
            "category": "",
            "content": "Python 강좌는 여러 절로 구성되어 있습니다.     Python 강좌(1) - Python 기본    Python 강좌(2) - Python 제어문    이 글은 pyhon의 제어문에 대한 내용 입니다.!!# Jekyll configurationmarkdown: kramdown# kramdown : markdown의 개조판.# markdown에서 불편한 사항을 개선한 형태.# MyData 인적 사항owner:  name:           sanseongKo  avatar:         photo.jpg  bio:            &quot;Ph.D. in Computer Science&quot;  email:          tkstjd56@naver.com  # Social networking links used in footer. Update and remove as you like.  twitter:  facebook:  github:  stackexchange:  linkedin:  instagram:  flickr:  tumblr:  # google plus id, include the &#39;+&#39;, eg +mmistakes  google_plus:highlighter: rouge# text highlighter로 rouge이용# 2016.02월 이후로 syntax highlighter는 rouge만 지원.# Pygments 사용불가.paginate: 20# 작성한 모든 post를 하나의 페이지에 열거할 수 없으니# pagination이 필요하고 몇개의 post를 하나의 page에서# 보여줄 건지를 설정.language: &#39;en-uk&#39;# 언어 설정url: https://sanseongKo.github.io# Google Search Console에서 사용하는 sitemap.xml 생성시# 이 url key값이 존재하지 않으면 sitemap.xml이# 정상적으로 생성되지 않는다.# 또한 disqus(댓글시스템)를 이용하기 위해서도 필요.# 자신의 github page url을 입력# ( https://your_github_id.github.io 형식 )baseurl: /# Website infotitle: IT Technical Training# 자신의 blog title.description: IT기반기술교육 블로그# blog home에 표시될 blog에 대한 전반적인 설명.cover: assets/built/images/blog-cover1.jpg# blog home에 표시될 blog cover image.logo:logo_dark:favicon: assets/built/images/favicon.jpg# favicon으로 사용할 imageproduction_url: https://sanseong.github.io# 최종적으로 blog가 운영될 urlsource_url: https://github.com/sanseongKo/GitHubPage# blogmaker(jekyll source folder)에 대한 github repository# Social infonavigation: True# Navigation bar link를 보여줄건지 여부subscribers: True# subscriber 기능을 사용할건지의 여부# 저는 약간의 수정을 통해 subscriber 기능대신# lunr.js를 이용한 검색 기능으로 대체 사용했습니다.# 검색기능으로 대체하기 위해서# `_includes/subscribe-form.html` 파일의 수정이 필요합니다.twitter:facebook:# 만약 twitter와 facebook을 이용하면 username을 입력# Disqusdisqus: Truedisqus_shortname: xxxxxxxx# disqus는 온라인 댓글 시스템. 댓글 기능을 사용하기 위해# disqus를 이용할 것인지 여부와 만약 사용하면# disqus shortname을 입력 ( disqus username이 아님 )# Google Analyticsgoogle_analytics: UA-xxxxxxxx-x # replace with your GA tracking identifier# Google Analytics을 사용할 경우 GA tracking identifier를 입력# Permalinkspermalink: /:title# permalink: /author/:author# permalink: /tag/:title# 각각의 post에 고정주소를 어떤 방식으로 할당할 것인지를 결정# 이 값을 바꾸면 작성한 포스트의 저장위치나 파일이름이 변경된다.# gems and other configsplugins: [jekyll-paginate, jekyll-feed, jekyll-gist]feed:  path: feed.xml# Travis-CI 설정입니다. 배포 빌드 자동화safe: Falselsi: Falseusername: tkstjd56repo: GitHubPageMaker# username : travis-ci와 연동하는 github의 username# repo: travis-ci와 연동하는 github의 repository이름# https://github.com/&lt;username&gt;/&lt;repository&gt;branch: master# 사용할 branch명relative_source:destination: ../[GitHubPage]/#./output/# compile된 결과가 생성되는 폴더# 이 폴더안의 내용이 우리가 운영하는 블로그 내용이 컴파일되서 들어간다.# 이 폴더안의 내용을 github repository(https://username.github.io)에 push# 만약 Travis-CI를 이용할 예정이면 이 부분을 git submodule로# github repository(https://username.github.io)에 연결해야 한다.# exclude는 Jekyll컴파일 시 destination에 포함될 필요가# 없는것들을 명시한다. (node_modules와 필요없는 것들은 제외)exclude:  - README.md  - Rakefile  - Gemfile  - Gemfile.lock  - changelog.md  - &quot;*.Rmd&quot;  - vendor  - .travis.yml  - node_modules  - assets/css  - assets/images  - _posts/angular  - _posts/et-cetera # - _posts/python  - _posts/typescript  #  - _posts/jekyll  - _posts/iot  - _posts/r  - _posts/economy",
        "url": "/python-control-statement"
    }
    ,
    
    "python-basic": {
        "title": "Python 강좌(1) - Python 기본",
            "author": "sanseongKo",
            "category": "",
            "content": "Python 강좌는 여러 절로 구성되어 있습니다.     Python 강좌(1) - Python 기본    Python 강좌(2) - Python 제어문    이 글은 pyhon basic에 입니다.!!function syntaxHighlight(code) {   var foo = 'Hello World';   var bar = 100;}",
        "url": "/python-basic"
    }
    
    
    };
</script>
<script src="assets/js/lunr.js"></script>
<script src="assets/js/search.js"></script>
            </section>

        </article>

    </div>
</main>

<!-- /post -->

<!-- The #contentFor helper here will send everything inside it up to the matching #block helper found in default.hbs -->
<script>
$(function() {
    var $postContent = $(".post-full-content");
    $postContent.fitVids();
});
</script>



        <!-- Previous/next page links - displayed on every page -->
        

        <!-- The footer at the very bottom of the screen -->
        <footer class="site-footer outer">
            <div class="site-footer-content inner">
                <section class="copyright"><a href="https://sanseongKo.github.io/">SanseongKo's Blog</a> &copy; 2021</section>
                <section class="poweredby">Proudly published with <a href="https://jekyllrb.com/">Jekyll</a> &
                    <a href="https://pages.github.com/" target="_blank" rel="noopener">GitHub Pages</a> using
                    <a href="https://github.com/jekyller/jasper2" target="_blank" rel="noopener">Jasper2</a></section>
                <nav class="site-footer-nav">
                    <a href="/">Latest Posts</a>
                    
                    
                    <a href="https://ghost.org" target="_blank" rel="noopener">Ghost</a>
                </nav>
            </div>
        </footer>

    </div>

    <!-- The big email subscribe modal content -->
    
    <div id="subscribe" class="subscribe-overlay">
        <a class="subscribe-overlay-close" href="#"></a>
        <div class="subscribe-overlay-content">
            
            <h1 class="subscribe-overlay-title">Search SanseongKo's Blog</h1>
            <p class="subscribe-overlay-description">
                lunr.js를 이용한 posts 검색 </p>
            <span id="searchform" method="post" action="/subscribe/" class="">
    <input class="confirm" type="hidden" name="confirm"  />
    <input class="location" type="hidden" name="location"  />
    <input class="referrer" type="hidden" name="referrer"  />

    <div class="form-group">
        <input class="subscribe-email" onkeyup="myFunc()"
               id="searchtext" type="text" name="searchtext"
               placeholder="Search..." />
    </div>
    <script type="text/javascript">
        function myFunc() {
            if(event.keyCode == 13) {
                var url = encodeURIComponent($("#searchtext").val());
                location.href = "/search.html?query=" + url;
            }
        }
    </script>
</span>
        </div>
    </div>
    

    <!-- highlight.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.10.0/components/prism-abap.min.js"></script>
    <script>$(document).ready(function() {
      $('pre code').each(function(i, block) {
        hljs.highlightBlock(block);
      });
    });</script>

    <!-- jQuery + Fitvids, which makes all video embeds responsive -->
    <script
        src="https://code.jquery.com/jquery-3.2.1.min.js"
        integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4="
        crossorigin="anonymous">
    </script>
    <script type="text/javascript" src="/assets/js/jquery.fitvids.js"></script>
    <script type="text/javascript" src="https://demo.ghost.io/assets/js/jquery.fitvids.js?v=724281a32e"></script>


    <!-- Paginator increased to "infinit" in _config.yml -->
    <!-- if paginator.posts  -->
    <!-- <script>
        var maxPages = parseInt('');
    </script>
    <script src="/assets/js/infinitescroll.js"></script> -->
    <!-- /endif -->

    


    <!-- Add Google Analytics  -->
    <!-- Google Analytics Tracking code -->
 <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-xxxxxxxx-x', 'auto');
  ga('send', 'pageview');

 </script>


    <!-- The #block helper will pull in data from the #contentFor other template files. In this case, there's some JavaScript which we only want to use in post.hbs, but it needs to be included down here, after jQuery has already loaded. -->
    
        <script>
$(function() {
    var $postContent = $(".post-full-content");
    $postContent.fitVids();
});
</script>

    

    <!-- Ghost outputs important scripts and data with this tag - it should always be the very last thing before the closing body tag -->
    <!-- ghost_foot -->

</body>
</html>
