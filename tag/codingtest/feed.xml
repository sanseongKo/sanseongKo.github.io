<?xml version="1.0" encoding="utf-8"?>

<feed xmlns="http://www.w3.org/2005/Atom" >
  <generator uri="https://jekyllrb.com/" version="3.9.0">Jekyll</generator>
  <link href="https://sanseongko.github.io/tag/codingtest/feed.xml" rel="self" type="application/atom+xml" />
  <link href="https://sanseongko.github.io/" rel="alternate" type="text/html" />
  <updated>2021-06-23T22:00:13+09:00</updated>
  <id>https://sanseongko.github.io/tag/codingtest/feed.xml</id>

  
  
  

  
    <title type="html">SanseongKo’s Blog | </title>
  

  
    <subtitle>온리 공부를 위한 블로그</subtitle>
  

  

  
    
      
    
  

  
  

  
    <entry>
      <title type="html">inflearn강의 복습</title>
      <link href="https://sanseongko.github.io/codingtest-codingclass" rel="alternate" type="text/html" title="inflearn강의 복습" />
      <published>2021-06-15T00:00:00+09:00</published>
      <updated>2021-06-15T00:00:00+09:00</updated>
      <id>https://sanseongko.github.io/codingtest-codingclass</id>
      <content type="html" xml:base="https://sanseongko.github.io/codingtest-codingclass">&lt;p&gt;뭔가 계속 불안해서 결국 인프런의 강의를 질렀다. 강의에서 나오는 내용들 위주로 공부를 진행하려고 한다.&lt;/p&gt;

&lt;h3&gt;String&lt;/h3&gt;
&lt;p&gt;&lt;b&gt;사전지식&lt;/b&gt;
&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;charAt(i) =&amp;gt; 문자열 위치(String “abcd”가 있으면 a는 charAt(1))&lt;/li&gt;
  &lt;li&gt;toCharArray =&amp;gt; char[]배열로 바꿔줌(위의 abcd를 배열로 바꿔줌)&lt;/li&gt;
  &lt;li&gt;IndexOf(), substring(begin, end) (특정 문자를 찾고 싶을 때, end인덱스는 마지막에서 끊는다)&lt;/li&gt;
  &lt;li&gt;startsWith(), endWith(), split() (ex. str.startWith(“a”)); =&amp;gt; true, split() =&amp;gt; 문자열을 특정 조건으로 스트링 배열로 바꿔줄 수 있음)&lt;/li&gt;
  &lt;li&gt;toLowerCase() =&amp;gt; 소문자로 바꿔줌&lt;/li&gt;
  &lt;li&gt;replace() =&amp;gt; 특정한 문자가 나오면 그거를 뭐로 바꿔줘라&lt;/li&gt;
  &lt;li&gt;Character,isDigit(c), Character.isLetter (전자 =&amp;gt; 0,1이런 숫자냐, 후자 =&amp;gt; 문자이냐) –&amp;gt; true&lt;/li&gt;
  &lt;li&gt;StringBuilder sb = new StringBuilder(); ex) sb.append(“aa”)&lt;/li&gt;
&lt;/ol&gt;

&lt;h3&gt;String 문제 1&lt;h3&gt;
1. Basic한 방법으로, 이메일이 담기는 배열을 파라미터로 받을 경우, for문을 돌려 각 이메일마다 charAt으로 나눠주고 조건을 확인시키는 방법이다. 
여기서 주의할 점은 substring(숫자) 이 숫자 부분이 배열의 번호부터 출력이 된다.
   
2. split을 가지고 하는 방법으로, 각 조건마다 split으로 String 배열로 만들어주고 그 배열을 replace(&quot;.&quot;, &quot;&quot;)로 바꿔주면 된다. 굉장히 간단했다.

&lt;br /&gt;&lt;br /&gt;

&lt;b&gt;1번 문제의 시간복잡도/공간복잡도 계산&lt;/b&gt;
&lt;br /&gt;&lt;br /&gt;
1. 시간 복잡도 : 대상 =&amp;gt; 문제에서 입력받은 파라미터 (속도)
2. 공간 복잡도 : 대상 =&amp;gt; 실제 사용되는 저장 공간을 계산
&lt;br /&gt;&lt;br /&gt;
&lt;b&gt;참고&lt;/b&gt;
   &lt;br /&gt;&lt;br /&gt;
1. O(1): 스택, 큐, Map
2. O(N): for문 =&amp;gt; 데이터를 한번씩 호출하기 때문
3. O(logN): sort, priorityQueue, binary Search Tree, Tree
4. O(KlogN): k번만큼 소팅하는 경우
5. O(N^2): 이중 for문
6. O(m*n): 이중 for문이지만, n이 다른 경우 bfs, dfs류 

&lt;br /&gt;&lt;br /&gt;
&lt;h3&gt;2. 보석 찾기 문제&lt;/h3&gt;

&lt;b&gt;Set&lt;/b&gt;은 대소문자를 구별한다. Set.contain(something) something이 Set에 들어있는지 확인 시켜줄 수 있다.(count를 할 때 유용할 듯)

&lt;h3&gt;3. 문자 파싱 문제&lt;/h3&gt;
&lt;b&gt;StringBuilder&lt;/b&gt;의 insert 메소드를 사용, (insert(8, &quot;!&quot;))이렇게 되어 있으면, 배열처럼 0번부터 시작해서 8번째에 해당 문자를 삽입한다.
삽입하고 딱 그자리에 들어가고 나머지는 밀리는 느낌이기 때문에, 잘 계산해서 사용하여야 겠다.

&lt;br /&gt;&lt;br /&gt;
제일 중요한건, 사실 생각인 것 같다. 코딩테스트 문제를 풀어봐도 항상 나는 구현쪽에서 막힌다.(그만큼 아는게 적다는 뜻이겠지)&lt;br /&gt;
어지간하면 문제 이해는 어렵지 않다. 어떤 것을 사용할지도 머리에 떠오르지만 중간 중간 문제되는 부분들에 막히면서 코드가 복잡해진다.&lt;br /&gt;
아는 선에서 생각하고 바로 떠오르긴 하지만 그것이 제대로 된 접근이 아니기 때문에 문제 해결을 위하여 코드가 추가되다보니 복잡해지고 시간을 잡아 먹는 것 같다.
초반 스트링의 관한 문제들이기 때문에, 그렇게 어렵게 다가오지 않았다. 원래 목표는 dfs,bfs의 이해이기 때문에(찾아보니, 속도가 굉장히 느린데 왜 쓰는건지 궁금;;) 달려보자.




&lt;/h3&gt;&lt;/h3&gt;</content>

      
      
      
      
      

      <author>
          <name>Ko</name>
        
        
      </author>

      

      
        <category term="codingtest" />
      

      
        <summary type="html">뭔가 계속 불안해서 결국 인프런의 강의를 질렀다. 강의에서 나오는 내용들 위주로 공부를 진행하려고 한다.</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">카카오 2021 블라인드 코딩테스트 1번</title>
      <link href="https://sanseongko.github.io/codingtest-2021_kakao01" rel="alternate" type="text/html" title="카카오 2021 블라인드 코딩테스트 1번" />
      <published>2021-06-15T00:00:00+09:00</published>
      <updated>2021-06-15T00:00:00+09:00</updated>
      <id>https://sanseongko.github.io/codingtest-2021_kakao01</id>
      <content type="html" xml:base="https://sanseongko.github.io/codingtest-2021_kakao01">&lt;h3&gt;문제&lt;/h3&gt;
&lt;p&gt;카카오에 입사한 신입 개발자 네오는 “카카오계정개발팀”에 배치되어, 카카오 서비스에 가입하는 유저들의 아이디를 생성하는 업무를 담당하게 되었습니다.
“네오”에게 주어진 첫 업무는 새로 가입하는 유저들이 카카오 아이디 규칙에 맞지 않는 아이디를 입력했을 때, 입력된 아이디와 유사하면서 규칙에 맞는 
아이디를 추천해 주는 프로그램을 개발하는 것입니다.
&lt;br /&gt;
&lt;a href=&quot;https://tech.kakao.com/2021/01/25/2021-kakao-recruitment-round-1/&quot;&gt;문제 자세히 보기&lt;/a&gt;&lt;/p&gt;

&lt;h3&gt;풀이&lt;/h3&gt;
&lt;p&gt;7가지의 조건들을 순서대로 적용하여 문제를 풀었다.
&lt;br /&gt;
&lt;script src=&quot;https://gist.github.com/sanseongKo/dab3325f2e1466eb26eca73783ed6b46.js&quot;&gt;&lt;/script&gt;
&lt;br /&gt;
순서대로 적용시키면 되기 때문에, 어렵진 않았지만 코드가 좀 더러운 느낌…?(멀었다… 멀었어…)&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/sanseongKo/codingtest&quot;&gt;깃허브에서 보기&lt;/a&gt;&lt;/p&gt;

&lt;h3&gt;새로 알게된 메소드&lt;/h3&gt;
&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nb&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;id&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;new_id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;toLowerCase&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;오 소문자로 바로 바꿔주더이다, 처음 생각한건 아스키 코드였는데 있다면 안 쓸 이유가 없지. 물론, new_id.toUpperCase();를 하면 대문자로 변환 해
준다.(대문자, 소문자만 확인하여 변환하고 숫자나 기타 특수문자는 건들지 않아서 문제에 유용했다.)
&lt;br /&gt;&lt;/p&gt;
&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nx&quot;&gt;char&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;answer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;toCharArray&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;솔직히 몰랐다… 반복으로 char 배열에 넣어줘야 하는 줄 알았다…&lt;/p&gt;

&lt;p&gt;다 풀고나서, 다른 분의 풀이를 보았다… 잘한다… 
&lt;br /&gt;
정규 표현식&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>Ko</name>
        
        
      </author>

      

      
        <category term="codingtest" />
      

      
        <summary type="html">문제 카카오에 입사한 신입 개발자 네오는 “카카오계정개발팀”에 배치되어, 카카오 서비스에 가입하는 유저들의 아이디를 생성하는 업무를 담당하게 되었습니다. “네오”에게 주어진 첫 업무는 새로 가입하는 유저들이 카카오 아이디 규칙에 맞지 않는 아이디를 입력했을 때, 입력된 아이디와 유사하면서 규칙에 맞는 아이디를 추천해 주는 프로그램을 개발하는 것입니다. 문제 자세히 보기</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">inflearn강의 Sort and Searching복습</title>
      <link href="https://sanseongko.github.io/codingtest-sortcodingclass" rel="alternate" type="text/html" title="inflearn강의 Sort and Searching복습" />
      <published>2021-06-15T00:00:00+09:00</published>
      <updated>2021-06-15T00:00:00+09:00</updated>
      <id>https://sanseongko.github.io/codingtest-sortcodingclass</id>
      <content type="html" xml:base="https://sanseongko.github.io/codingtest-sortcodingclass">&lt;p&gt;정렬 알고리즘 강의 들은 것에 관하여 정리를 해보려 한다.(요기요 코딩테스트도 오늘 보았다)
첫번째 문제에서는 조건에 맞는 배열의 데이터를 빼내어 다른 배열에 담고, 인덱스를 기억하여 정렬을 하는 것이 핵심이었다.
인덱스를 증가 시켜놓은 상태로, 또는 인덱스를 최대에서 줄이면서, 인덱스를 기억시켜놓고 인덱스에 맞게 정렬을 하는 방식이다.
언제나 문제의 조건을 정리하여 그대로 코딩화하는 것이 중요한 것 같다.&lt;/p&gt;

&lt;p&gt;두번째 문제는 힙을 이용하여 정렬을 하는 방법이고, 큰 수부터 정렬하여 그 중 몇 번째 숫자를 리턴하는 것이다.
Priority Queue&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>Ko</name>
        
        
      </author>

      

      
        <category term="codingtest" />
      

      
        <summary type="html">정렬 알고리즘 강의 들은 것에 관하여 정리를 해보려 한다.(요기요 코딩테스트도 오늘 보았다) 첫번째 문제에서는 조건에 맞는 배열의 데이터를 빼내어 다른 배열에 담고, 인덱스를 기억하여 정렬을 하는 것이 핵심이었다. 인덱스를 증가 시켜놓은 상태로, 또는 인덱스를 최대에서 줄이면서, 인덱스를 기억시켜놓고 인덱스에 맞게 정렬을 하는 방식이다. 언제나 문제의 조건을 정리하여 그대로 코딩화하는 것이 중요한 것 같다.</summary>
      

      
      
    </entry>
  
</feed>
